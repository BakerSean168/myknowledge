# 计算机组成原理

## 数据的机器级表示

### 数制和编码

#### 进制转换

##### 二进制和十进制

十进制小数转换为二进制小数  
十进制小数转换成二进制小数采用"乘2取整，顺序排列"法。具体做法是：用2乘十进制小数，可以得到积，将积的整数部分取出，再用2乘余下的小数 部分，又得到一个积，再将积的整数部分取出，如此进行，直到积中的小数部分为零，或者达到所要求的精度为止。  
然后把取出的整数部分按顺序排列起来，先取的整数作为二进制小数的高位有效位，后取的整数作为低位有效位。
例如把（0.8125）转换为二进制小数。  

#### 原码、反码、补码、移码

https://www.bilibili.com/video/BV19m421N7og?spm_id_from=333.788.videopod.sections&vd_source=15c229538881316b8c6a43f997de056f

##### 原码（Sign-Magnitude）

原码是一种最简单的表示方法，使用最高位作为符号位，其余位表示数值的绝对值。

符号位：0 表示正数，1 表示负数
数值位：表示数值的绝对值
示例：
+6 的原码表示：0000 0110
-6 的原码表示：1000 0110

##### 反码（Ones' Complement）

反码用于表示负数，通过将原码的数值位逐位取反得到。

正数：反码与原码相同
负数：符号位不变，数值位逐位取反
示例：
+6 的反码表示：0000 0110
-6 的反码表示：1111 1001

##### 补码（Twos' Complement）

补码是计算机中最常用的表示方法，特别适用于算术运算。负数的补码是其反码加 1。

正数：补码与原码相同
负数：反码加 1
示例：
+6 的补码表示：0000 0110
-6 的补码表示：1111 1010
计算过程：
原码：1000 0110
反码：1111 1001
补码：1111 1001 + 1 = 1111 1010

##### 移码（Excess-N）

移码是一种用于浮点数表示的编码方式，通过在数值上加一个偏移量（通常是 2^(n-1)）来表示。

正数：移码 = 数值 + 偏移量
负数：移码 = 数值 + 偏移量
示例（假设偏移量为 8，即 2^3）：
+3 的移码表示：3 + 8 = 11 -> 1011
-3 的移码表示：-3 + 8 = 5 -> 0101

*0的反码、补码都为0*

#### 定点和浮点

日常生活中所使用的数值数据有整数和实数之分，整数的小数点固定在数的最右边，可
以省略不写，而实数的小数点则不固定。计算机内部数据中每一位只能是0或1,不可能出
现小数点，因此，要使得计算机能够处理日常使用的数值数据，必须要解决小数点的表示问
题。通常计算机中通过约定小数点的位置来实现。小数点位置约定在固定位置的称为定点
数，小数点位置约定为可浮动的称为浮点数。  
因为任意一个浮点数都可以用一个定点小数和一个定点整数来表示，所以，只需要考虑
定点数的编码表示。  

##### 定点数

定点数是一种数值表示方法，其中小数点的位置是固定的。定点数可以用于表示整数或小数，具体取决于小数点的位置。定点数在计算机系统中常用于需要固定精度的场景  

通常将在计算机内部编码表示后的数称为机器数，而机器数真正的值(即现实世界中带有正负号的数)称为机器数的真值  

- 原码表示法  
    一个数的原码表示由符号位直接跟数值位构成，因此，也称“符号-数值(sign andmagnitude)”表示法。原码表示法中，正数和负数仅符号位不同，数值部分完全相同。  
    原码表示的优点是，与真值的对应关系直观、方便；其缺点是，0的表示不唯一，给使用带来不便，并且原码运算中符号和数值部分必须分开处理。  
- 补码表示法

### 整数的表示  

### 实数的表示

计算机内部进行数据存储、运算和传送的部件位数有限，因而用定点数表示数值数据时，其表示范围很小。n位带符号整数表示范围为。。。,运算结果很容易溢出，此外，用定点数也无法表示大量带有小数点的实数。因此，计算机中专门用浮点数来表示实数  

#### 浮点数格式  

![alt text](AAA_PictureDir_test/image-1.png)  

#### 浮点数规格化

#### 浮点数标准

#### 浮点数运算

基数（也称为底数或基数）：是指用于表示数值的进制系统。

尾数（Mantissa）：尾数是浮点数表示中的有效数字部分。它表示数值的精度。

大阶（Larger Exponent）：大阶是指浮点数中指数部分较大的那个数。

小阶（Smaller Exponent）：小阶是指浮点数中指数部分较小的那个数。

对阶（Aligning the Exponents）：对阶是指在进行浮点数加减运算时，将两个浮点数的指数对齐，使它们具有相同的指数。这样可以方便地进行尾数的加减运算。

- 规格化（Normalization）
    规格化是指将浮点数表示为尾数的绝对值在一定范围内的形式，通常是使尾数的最高位为非零。规格化可以确保浮点数表示的唯一性和精度。
    ```
    让浮点数小数的后面的数字为有效数字  
    0.0012302*10^5 => 0.12302*10^3  

    规格化操作有两种：“左规”和“右规”。当有效数位进到小数点前面时，需要进行右规。  
    右规时，尾数每右移一位，阶码加1,直到尾数变成规格化形式为止，右规时指数会增加，因此有可能溢出；  
    左规时，尾数每左移一位，阶码减1,直到尾数变成规格化形式为止。  
    ```

下溢：计算结果的绝对值小于计算机所能表示的最小非零正数时，就会发生下溢。这种情况通常会导致结果被舍入为零，因为计算机无法表示如此小的数值。

### 非数值数据的编码表示

### 数据的宽度和存储

---

## 运算方法和运算部件  

CPU 运算方法中，运算结果发生溢出的特征是
- 两操作数的符号位相同，并与运算结果的符号位不相同  
- 运算结果的符号位进位和最高有效位的进位都是不相同

### 高级语言和机器指令中的运算

#### C

#### MIPS

### 基本运算部件  

全加器和加法器  
并行进位加法器  
带标志加法器  
算术逻辑部件  

### 定点数运算  

补码加减运算  
原码加减运算  

#### 原码乘法运算  

原码乘法是计算机中实现有符号数乘法的一种方法，它直接基于数学乘法规则，但需要额外的步骤来处理符号位。在原码表示法中，最高位用于表示数的符号（0为正，1为负），其余位表示数值大小。原码乘法的基本思想是将两个数的绝对值相乘，然后根据两数的符号确定结果的符号。  

原码乘法的过程  
```
符号位判断：首先检查两个操作数的符号位。如果两个操作数的符号相同，则结果为正；如果不同，则结果为负。
取绝对值：忽略符号位，只对数值部分进行乘法运算。
乘法运算：按照无符号整数乘法的方式进行逐位相乘。对于二进制数来说，这意味着每一位与另一个数的所有位相乘，然后将结果相加。
结果符号设置：根据第一步的结果设置最终乘积的符号位。
调整结果格式：如果需要，将乘积转换回原码格式。
```

#### 补码乘法运算  

##### 补码乘法器

```
下面有关定点补码乘法器的描述中，正确的是（   ）   
选项A）被乘数的符号和乘数的符号都参加运算  
选项B） 乘数寄存器必须具有右移功能，并增设一位附加位，其初态为“1” （初始为0）  
选项C）乘数使用双符号位   (被乘数使用双符号位)   
选项D）用计数器控制乘法次数，若乘数尾数为n位，当计数器计到n+1时完成乘法运算并移位    (不移位)  
```

##### 原码不恢复余数法(又称原码加减交替法)的算法

##### 比较法

在补码乘法中，比较法（也称为 Booth's Algorithm）是一种用于乘法运算的算法。该算法通过检查乘数的相邻两位来决定下一步的操作。具体规则如下：

相邻两位为 00 或 11：
不进行加法操作，只右移一位。  
相邻两位为 01：
将被乘数的补码（即负数）加到部分积上，然后右移一位。
相邻两位为 10：
将被乘数的原码（即正数）加到部分积上，然后右移一位。

示例：
假设被乘数 ( X ) 和乘数 ( Y ) 的补码表示如下：

被乘数 ( X ) 的补码表示为 [X]补
乘数 ( Y ) 的补码表示为 [Y]补
在进行补码一位乘法时，如果相邻两位乘数 ( Y_i Y_{i+1} ) 为 01，则下一步操作是将被乘数的补码（即负数）加到部分积上，然后右移一位。  

```
判断y的最后两位的时候，遵循这样的规则： 
为00或者为11的时候，直接右移一位 
为01的时候，加x的补，然后右移一位 
为10的时候，加-x的补，然后右移一位
```

##### 若采用双符号位补码运算，运算结果的符号位

```
第一符号位表示最终结果的符号，第二符号位表示运算结果是否溢出 
当第二位和第一位符号相同，则未溢出,不同，则溢出 
01 表示正溢出，10表示负溢出
```

#### 快速乘法器  
#### 原码除法运算  
#### 补码除法运算  

### 整数乘除运算  

溢出判断  
常量的乘除运算  

### 浮点数运算  

加减  
运算精度和舍入  
乘除  

---

## 指令系统  

### 指令格式设计  

指令地址码个数  
指令格式设计原则  

### 指令系统设计

操作数类型  

#### 寻址方式  

指令不仅要规定所执行的操作，还要给出操作数或操作数地址。操作数可能是一个常
数，或一个简单变量，或是数组和结构中的某个元素，也可能是栈(stack)中的数据，还可能
是外设I/O接口中的状态字或控制字等。从指令的角度来看，操作数存放位置可以是CPU
中的通用寄存器、存储单元和1/O端口。通常把指令中给出的操作数所在存储单元的地址
称为有效地址，存储单元地址可能是主存物理地址，也可能是虚拟地址。若不采用虚拟存储
机制，有效地址就是主存物理地址；若采用虚拟存储机制，则有效地址就是虚拟地址。  
指令给出操作数或操作数地址的方式称为寻址方式。地址字段长度直接影响指令长
度，因而指令的地址码要尽量短，但操作数的存放位置又必须灵活，存放空间也应尽量大。
因此，指令系统应能提供灵活的寻址方式，并使用尽量短的地址码访问尽可能大的寻址空
间。此外，为加快指令执行速度，有效地址计算过程也应尽量简单。

指令系统中采用不同寻址方式的目的主要是**缩短指令长度，扩大寻址空间，提高编程灵活性**  

- 立即寻址  
- 直接寻址  
- 间接寻址  
- 寄存器寻址  
- 寄存器间接寻址  
- 变址寻址  
    变址寻址方式主要用于对线性表之类的数组元素进行访问。  
    采用变址寻址可扩大寻址范围，且**变址寄存器内容由用户确定，在程序执行过程中可变**  
- 相对寻址  
- 基址寻址  
- 其他寻址方式  


#### 操作类型  

操作码编码  
标志信息的生成与使用  
指令系统设计风格  
异常和中断处理机制  

### 程序的机器级表示  

MIPS 汇编语言和机器语言  
选择结构  
循环结构  
过程调用  

## 指令集架构

### RISC（精简指令集计算机）

RISC 设计的一个目标是使大多数指令在一个时钟周期内完成，以提高执行效率。

RISC 处理器通常具有更多的内部通用寄存器，以减少对内存的访问，提高性能。

RISC 的设计原则之一是简化指令集，因此 RISC 的指令数、寻址方式和指令格式种类相对 CISC（复杂指令集计算机）少。

### CISC

## 处理器型号

### x86

早期，1980s年代，x86一般指当时的处理器8088和80286，不过这两个处理器都是16位的。如今，x86通常指32位指令集架构的处理器，比如80386。80386处理器是intel在1985年实现的第一款32位指令集架构的处理器，又叫i386，Intel Architecture, 32-bit，缩写为IA-32，现在，IA-32一般又能引喻成所有的支持32位计算的x86架构。

按照发展历史看，x86应该是指令集概念，一般用于个人PC系统如8086,286,386。IA-32是intel首推的32位架构。

### x86-64/x64/amd64/Intel64

在1999年，AMD公司首先在IA-32基础上，增加了64位寄存器，兼容早期的16位和32位软件系统，推出了x86-64的64位微处理器，后来命名为AMD64，实现了超车。然后intel公司也接受了该方案，叫做Intel64。x86-64应该只算是x86指令集的64位扩展，并不是一种全新的64位架构。

由于amd64和intel64本质上是一样的，叫法也是很多。AMD通常叫它x86-64、x86_64，微软和sun等软件公司叫它x64，操作系统厂商则通常用AMD64或者amd64来指代AMD64和Intel64。

### IA-64

IA-64是Intel推出的用于Itanium处理器（安腾处理器）的自己的Intel Architecture 64位指令集，一般用于服务器。尽管Intel64也是64位处理器，但这两者完全不是一回事。IA-64软件不能直接运行于Intel64处理器上。x86-64是IA-32指令集的扩展，而IA-64则是完完全全没有一点IA-32影子的独立处理器架构。IA-64需要通过模拟器才能运行IA-32，但是性能大大受影响。

### 市面上处理器如何区分AMD64和IA-64呢？

市面上买的Intel 64-bit的cpu其实都属于amd64分类，intel64和amd64其实都应该叫做x86_64。  
IA64则指Itaniums系统cpu，并不是x86架构的，一般都是用于服务器，不是个人桌面产品，价格昂贵。  
ARM64/AArch64  
ARM是精简指令集RISC下的处理器架构。ARMv3至ARMv7支持32位寻址空间。ARMv8-A开始支持64位寻址空间。AArch64和ARM64都是指64位的ARM架构。  

---

## CPU

CPU内部主要由运算器、控制器、寄存器三大部分组成。  

运算器 负责算术运算（+ - * / 基本运算和附加运算）和逻辑运算（包括 移位、逻辑测试或比较两个值等）。  
控制器 负责应对所有的信息情况，调度运算器把计算做好。  
寄存器 它们可用来暂存指令、数据和地址。既要对接控制器的命令，传达命令给运算器；还要帮运算器记录处理完或者将要处理的数据。  

![alt text](AAA_PictureDir_CSKnow/image-11.png)  
![alt text](AAA_PictureDir_CSKnow/image-12.png)  

### CPU 参数

#### 指令周期

CPU从主存取出一条指令加上执行一条指令的时间

#### 机器周期

由于 CPU 内部操作的速度较快，而 CPU 访问一次存储器的时间较长，因此机器周期通常由存取周期来确定。

#### 主频（Clock Speed）

- **定义**：CPU 的时钟频率，通常以 GHz（千兆赫兹）为单位。
- **作用**：主频越高，CPU 每秒钟可以执行的指令周期越多，处理速度越快。
- **影响因素**：主频受制于制程工艺、散热能力和电压等因素。
- **示例**：一个 3.5 GHz 的 CPU 每秒钟可以执行 3.5 亿个时钟周期。

#### CPI（Cycles Per Instruction）

- **定义**：每条指令所需的时钟周期数。
- **作用**：CPI 是衡量 CPU 执行效率的一个重要指标。CPI 越低，CPU 执行指令的效率越高。
- **计算公式**：CPI = 总时钟周期数 / 指令数
- **影响因素**：CPI 受指令集架构、指令类型、流水线深度和缓存命中率等因素影响。
- **示例**：如果一个程序执行了 1000 条指令，花费了 4000 个时钟周期，则 CPI = 4000 / 1000 = 4。

#### MIPS（Million Instructions Per Second）

- **定义**：每秒钟执行的百万条指令数。
- **作用**：MIPS 是衡量 CPU 执行速度的一个指标，但不能完全反映 CPU 的实际性能，因为不同指令的执行时间不同。
- **计算公式**：MIPS = 主频（MHz） / CPI
- **影响因素**：MIPS 受主频和 CPI 的共同影响。
- **示例**：一个主频为 2 GHz，CPI 为 2 的 CPU，其 MIPS = 2000 / 2 = 1000 MIPS。

#### MFLOPS（Million Floating-Point Operations Per Second）

- **定义**：每秒钟执行的百万次浮点运算数。
- **作用**：MFLOPS 是衡量 CPU 浮点运算能力的一个指标，常用于科学计算和图形处理等需要大量浮点运算的应用。
- **计算公式**：MFLOPS = 浮点运算数 / 执行时间（秒） / 10^6
- **影响因素**：MFLOPS 受浮点单元的性能、指令集和优化算法等因素影响。
- **示例**：如果一个程序执行了 10 亿次浮点运算，花费了 2 秒钟，则 MFLOPS = 10^9 / 2 / 10^6 = 500 MFLOPS。

#### 参数比较

| 参数 | 定义 | 作用 | 计算公式 | 影响因素 |
| --- | --- | --- | --- | --- |
| 主频 | CPU 的时钟频率 | 决定 CPU 每秒钟可以执行的指令周期数 | - | 制程工艺、散热能力、电压 |
| CPI | 每条指令所需的时钟周期数 | 衡量 CPU 执行效率 | CPI = 总时钟周期数 / 指令数 | 指令集架构、指令类型、流水线深度、缓存命中率 |
| MIPS | 每秒钟执行的百万条指令数 | 衡量 CPU 执行速度 | MIPS = 主频（MHz） / CPI | 主频、CPI |
| MFLOPS | 每秒钟执行的百万次浮点运算数 | 衡量 CPU 浮点运算能力 | MFLOPS = 浮点运算数 / 执行时间（秒） / 10^6 | 浮点单元性能、指令集、优化算法 |

### 控制器

控制器由程序计数器（PC，Program Counter）、指令寄存器（IR，Instruction Register）、指令译码器（ID，Instruction Decoder）、时序产生器（Timing Generator）、操作控制器（Control Unit）组成。  
```
指令寄存器IR，是用来存放当前正在执行的的一条指令，存放的内容来自于数据寄存器（DR，Data Register）。当一条指令需要被执行时，先要把它从内存取到数据寄存器，然后再送到指令寄存器IR中。
指令译码器ID，在计算机执行一条指定的指令时，必须首先分析这条指令的操作码是什么，以决定操作的性质和方法，然后控制计算机的其他各部件协同完成指令表达的功能，这中间的分析工作就是指令译码器ID完成的。
程序计数器PC，用来存放下一条要执行指令的地址，它与存储器（内存）之间有一条直接通路。执行指令时，首先需要根据程序计数器PC中存放的指令地址，将指令由内存取到指令寄存器IR，完成“取指令”的操作。程序计数器PC本身具有自动加1的功能，可以自动给出下一条指令的地址，如此循环，执行每一条指令。
时序产生器，类似于“时间作息表”，给计算机各部分提供工作所需的时间标志，一般是利用定时脉冲的顺序和不同的脉冲间隔来实现。
```
操作控制器，根据指令所需完成的操作和信号，发出各种微操作命令序列，用以控制所有被控对象，完成指令的执行。
整个控制器的运行逻辑是先按照程序计数器所指出的指令地址，从内存中取出一条指令到指令寄存器IR，然后指令译码器ID对指令进行分析，之后操作控制器根据指令的功能向有关部件发出控制命令，执行控制指令的操作。完成操作之后，程序计数器加1，再重复执行上述操作。

能对指令进行译码

### 运算器

运算器，一般最少包括3个寄存器和1个算术逻辑单元(ALU)，现代计算机内部往往设有通用寄存器组。  

寄存器，一种有限存储容量的高速存储部件，可用来暂存指令、数据和位址。寄存器有很多种类，一般涉及到四则运算的有3类，ACC（Accumulator）为累加器，MQ（Multiplier-Quotient Register）为乘商寄存器，X为操作数寄存器，3类寄存器在完成不同运算时，所存放的操作数类别也各不相同。  
![alt text](AAA_PictureDir_CSKnow/image-13.png)  

关于乘积高位和乘积低位的概念，以十进制为例，百位就是十位的高位，十位是百位的低位。两个16位数相乘，结果可能会有32位，那左半部分的16位就是乘积高位，存储到ACC中，右半部分的16位就是乘积低位，存储到MQ中。  
算术逻辑单元（ALU，Arithmetic and Logic Unit），是算术运算和逻辑运算的部件。算术运算包括加、减、乘的整数运算，逻辑运算是与、或、非和异或等逻辑操作，还有移位、比较和传送等操作。  
移位运算，将一个字符向左或向右移动位，或是浮动特定位，包含带符号延伸和无符号延伸，在程序中应用很广泛。  

#### ALU（算术逻辑单元）

ALU 的位数（宽度）不一定与机器字长相同。ALU 可以处理不同位数的数据，例如 8 位、16 位、32 位或 64 位，具体取决于 CPU 的设计。


### 寄存器

#### 通用寄存器

| **寄存器** | **用途**                                      |
|------------|-----------------------------------------------|
| AX（累加器） | 用于算术运算和 I/O 操作                       |
| BX（基址寄存器） | 常用于存放地址                              |
| CX（计数器） | 用于循环和位移操作                            |
| DX（数据寄存器） | 用于存放数据，特别是在双字长运算中          |

#### 变址寄存器

| **寄存器** | **用途**                                      |
|------------|-----------------------------------------------|
| SI（源变址寄存器） | 用于存放源地址偏移                        |
| DI（目的变址寄存器） | 用于存放目的地址偏移                      |

变址寄存器内容由用户确定，在程序执行过程中可变。  

#### 指针寄存器

| **寄存器** | **用途**                                      |
|------------|-----------------------------------------------|
| SP（堆栈指针） | 用于存放栈的偏移地址                        |
| BP（基址指针） | 用于基址寻址，特别是在函数调用中            |

#### 段寄存器

| **寄存器** | **用途**                                      |
|------------|-----------------------------------------------|
| DS（数据段寄存器） | 用于存放数据段地址                      |
| ES（附加段寄存器） | 用于存放附加段地址                      |

#### 控制寄存器

##### PC（程序计数器）

存储下一条要执行的指令的地址 copilot ？CPU的程序计数器中存放的是操作数地址 学习通

CPU中决定指令执行顺序的是程序计数器

程序计数器（PC）和存储器地址寄存器（MAR）的位数通常是一样的，因为它们都用于存储内存地址。

程序计数器（PC）的值由CPU在执行指令过程中自动进行修改，以指向下一条要执行的指令。

##### IR（指令寄存器）

存储当前正在执行的指令

#### 状态寄存器

##### Flags（标志寄存器）

存储运算结果的状态信息，如进位、溢出、零标志等

状态寄存器中的各个状态标志位是依据**算术逻辑部件上次的运算结果**来设置的

状态寄存器中的标志位对用户并不是完全透明的，用户可以通过特定指令访问和修改某些标志位。

![alt text](img/assimg-19.png)
6个状态标志位：OF、SF、ZF、AF、PF、CF，及3个控制标志位DF、IF、TF
标志寄存器Flag
Flag是16位的寄存器，有9个标志位，其中6个状态标志位，3个控制标志位
 
6个状态标志位
CF：进位或者借位 有进位或者借位时CF=1，并且debug显示为CY
否则CF=0，debug显示为NC
 
PF：奇偶标志位 用于校验，运算结果**低8位**（AL AH等） 化为2进制 为奇数个1时PF=0 debug显示 PO
否则 偶数个1时PF=1 debug显示PE
 
AF:辅助进位标志 运算结果的低4位向前1位有进位或者借位时 AF=1，debug显示AC
否则无进位和借位时AF=0,debug显示NA
 
ZF:零标志位 运算结果为0时 则ZF=1，debug显示ZR
否则ZF=0，debug显示NZ
 
SF:符号标志位 运算结果为负数时，SF=1，debug显示NG
否则SF=0，debug显示PL
 
OF:溢出标志位 如果运算结果溢出(与常识不符合 例如两个正数相加为负数 或者两个异数相减为负数)，则ZF=1,debug显示OV
否则ZF=0，debug显示NV
 
3、3个控制标志位
TF:追踪标志位
TF=1则单步执行，执行之后TF=0 即中断然后正常执行
 
IF:中断允许标志位
IF=1,则允许CPU响应外部中断 debug 显示EI
IF=0,则禁止 debug显示DI
 
DF:方向标志位
DF=1，地址减方向 debug显示DN
DF=0,地址增方向 debug显示UP

### 三类总线

地址总线：决定存储单元，地址总线的宽度决定了可寻址的存储单元的大小 // 8086总线宽度为20，寻址空间（内存地址空间）为2^20B(1MB)
数据总线：传输数据，数据总线的宽度决定了CPU和外界的数据传送速度
控制总线：对外部器件进行控制，控制总线的宽度决定了CPU对外部器件的控制能力

### 指令流水线数据通路

指令流水线数据通路是 CPU 中用于执行指令的硬件路径。它包括多个阶段，每个阶段执行指令的一部分操作。以下是对各个选项的解释：

A. 由组合逻辑电路和时序逻辑电路组合而成：

正确。指令流水线数据通路由组合逻辑电路和时序逻辑电路组成，以实现指令的并行处理和时序控制。
B. 包含通用寄存器组和取指部件：

正确。指令流水线数据通路包含通用寄存器组（用于存储操作数和结果）和取指部件（用于从存储器中取指令）。
C. 不包含存储器：

错误。指令流水线数据通路需要访问存储器以取指令和数据。存储器是指令流水线数据通路的重要组成部分。
D. 包含算术逻辑运算部件(ALU)：

正确。指令流水线数据通路包含算术逻辑运算部件（ALU），用于执行算术和逻辑运算。

### 微程序控制器

机器指令与微指令的关系是：  
微程序控制器通过一段微指令（微程序）来解释和执行每一条机器指令。每条机器指令对应一个微程序，该微程序由若干条微指令组成，用于控制CPU的各个部分完成指令的执行。

为确定下一条微指令的地址，通常采用断定方式，其基本思想是：  
）通过微指令顺序控制字段由设计者指定或由设计者指定的判别字段控制产生后继微指令地址  

微指令执行周期对应的是 机器周期  

### CPU 运算方法

### CPU 概述

#### 基本功能

#### 基本组成

随着超大规模集成电路技术的发展，更多的功能模块被集成到 CPU 芯片中，包括
cache、MMU、浮点运算逻辑、异常和中断处理逻辑等，因而CPU的内部组成越来越复杂，甚
至在一个 CPU芯片中集成了多个处理器核。但是，不管 CPU多复杂，数据通路(datapath)
和控制器(control unit)是其两大基本组成部分。控制器也称为控制部件。  

#### 数据通路与时序控制  

时序控制中的同步控制是**由统一时序信号控制的方式**

### 单周期处理器设计

### 多周期处理器设计

### 带异常处理器设计  

---

## 指令流水线

### 概述  

### 实现  

### 流水线冒险及其处理  

- 结构冒险（Structural Hazard）
- 数据冒险（Data Hazard）
- 控制冒险（ControlHazard）

---

## 存储器层次结构  

### 概述  

![alt text](AAA_PictureDir_CSKnow/image.png)

| 存储器类型                             | 说明                                                                                       | 特点                                                              | 用途                                                                                                                    |
|-----------------------------------|------------------------------------------------------------------------------------------|-----------------------------------------------------------------|-----------------------------------------------------------------------------------------------------------------------|
| SRAM（Static Random Access Memory） | SRAM 是静态随机存取存储器，它使用双稳态触发器（如触发器）来存储每一位数据。由于每个存储单元由多个晶体管组成，SRAM 不需要像 DRAM 那样定期刷新数据，因此速度较快。 | -速度快：由于不需要刷新，SRAM 的访问速度比 DRAM 快。 <br>-功耗低：在不进行读写操作时，SRAM 的功耗较低。 | -高速缓存（Cache）：SRAM 常用于 CPU 的一级缓存（L1 Cache）、二级缓存（L2 Cache）和三级缓存（L3 Cache）。<br>-嵌入式系统：由于其速度快和功耗低，SRAM 也常用于嵌入式系统中的高速存储需求。 |
| DRAM（Dynamic Random Access Memory） | DRAM 是动态随机存取存储器，它使用电容来存储每一位数据。由于电容会漏电，DRAM 需要定期刷新数据以保持其内容，因此速度较慢。 | -速度较慢：由于需要定期刷新，DRAM 的访问速度比 SRAM 慢。 <br>-功耗较高：刷新操作需要消耗额外的功率，因此 DRAM 的功耗较高。 <br>-集成度高：每个存储单元只需要一个电容和一个晶体管，因此 DRAM 的集成度较高，单位面积内的存储容量较大。 <br>-成本低：由于使用了较少的晶体管，DRAM 的制造成本较低。 | -主存储器（Main Memory）：DRAM 常用于计算机的主存储器（RAM），如 DDR SDRAM、DDR2、DDR3、DDR4 等。<br>-图形存储器（Graphics Memory）：DRAM 也常用于图形处理器（GPU）的显存（VRAM）。 |

### 半导体随机存取存储器  

### 外部辅助存储器

### 存储器的数据校验

### 高速缓冲存储器（cache）

通过提高存储芯片本身的速度或采用多模块存储器结构可以缓解 CPU 和主存之间的速度匹配问题。除了这两种方法之外，在 CPU 和主存之间设置高速缓存（cache）也可以来提高 CPU 访问指令和数据的速度。  

#### 程序访问的局部性

#### cache 基本工作原理

cache 是一种小容量高速缓冲存储器，由快速的SRAM组成，直接制作在 CPU 芯片内，速度几乎与 CPU 一样快。在 CPU 和主存之间设置 cache,把主存中被频繁访问的程序块计算机组成与系统结构(第3版)和数据块复制到 cache 中。由于程序访问的局部性，大多数情况下，CPU 能直接从 cache 中取得指令和数据，而不必访问主存。
为便于 cache 和主存间交换信息，cache 和主存空间都被划分为相等的区域。主存中的区域称为块(block),也称为主存块，它是 cache 和主存之间的信息交换单位；cache 中存放一个主存块的区域称为行(line)或槽(slot)。  

#### cache 行和主存块之间的映射方式

在将主存块复制到 cache行时，主存块和 cache行之间必须遵循一定的映射规则。这样，CPU要访问某个主存单元时，可依据映射规则到 cache 对应的行中查找信息，而不用在整个 cache 中查找。  
根据不同的映射规则，主存块和 cache 行之间有以下3种映射方式。  
- 直接(direct):每个主存块映射到cache的固定行中。
- 全相联(full associate):每个主存块映射到 cache的任意行中。
- 组相联(set associate):每个主存块映射到 cache 固定组的任意行中。

##### 直接映射

直接映射的基本思想是把主存的每一块映射到固定的一个 cache行中，也称模映射，其映射关系如下：  
`cache 行号 = 主存块号 mod cache 行数`  

例如，假定cache共有16行，根据100 mod 16 = 4可知，主存第 100 块应映射到 cache 的第4
行中。

```
通常 cache的行数是2的n次幂，假定cache有2“行，主存有2”块，即以m位主存块号中低c位作为对应的 cache行号来进行 cache映射，即主存块号的低c位正好是它要装入的 cache行号。在cache中，给每一个行设置一个t位长的标记(tag),此处t=m-c,主存某块调入cache后，就将其块号的高t位设置在对应cache行的标记中。根据以上分析可知，主存地址被分成以下3个字段：

_____________________________  
|标记 | cache 行号 | 块内地址 |  
------------------------------  

其中，高t位为标记，中间c位为cache行号(也称行索引),剩下的低位地址为块内地址。
```

##### 全相联映射

全相联映射的基本思想是一个主存块可装入 cache 任意一行中。在全相联映射 cache 中，每行的标记用于指出该行取自主存的哪个块。因为一个主存块可能在任意一个 cache 行中，所以，需要比较所有cache行的标记，因此，主存地址中无须cache行索引，只有标记和块内地址两个字段。全相联映射方式下，只要有空闲 cache 行，就不会发生冲突，因而块冲突概率低。

##### 组相联映射

直接映射和全相联映射的优缺点正好相反，二者结合可以取长补短。因此将两种方式结合起来产生了组相联映射方式。  
组相联映射的主要思想是，将 cache所有行分成29个大小相等的组，每组有2°行。每个主存块被映射到 cache 固定组中的任意一行，即采用组间模映射、组内全映射的方式，映射关系如下：  
`cache组号 = 主存块号 mod cache 组数`  
_____________________________  
|标记 | cache 组号 | 块内地址 |  
------------------------------  


### 虚拟存储器  

---

## 系统互连及输入输出组织  

### 外部设备的分类与夜店  

### 常用输入输出设备  

#### 键盘  

#### 打印机  

#### 显示器

### 外设与 CPU 和主存的互连

### I/O 数据传送控制方式  

程序直接控制  
中断控制  
DMA  

### 内核空间 IO 软件

---

## 并行处理系统

---

 存储周期是指**存储器进行连续读或写操作所允许的最短间隔时间**  
 指令的地址码给出存储器地址的加法指令，在执行周期一定访存  
 阶码部件只进行阶码相加、相减和比较操作  

---

# 考试

选 40  
判断 10  
解答 5 * 6 2+5+6（数据冒险的解决方法）+8  
计算 2 * 10  
1. 第一章 性能指标相关计算 CPI List  
2. 主存和 Cache  三种映射关系

## 解答

### 2

1. 为什么计算机内部采用二进制表示信息？既然计算机内部所有信息都用二进制表示，为什么还要学习十六进制表示  
    二进制只有两种基本状态，使用有两个稳定状态的物理器件就可以表示二进制数的每一位，而制造有两个稳定状态的物理器件要比制造有多个稳定状态的物理器件容易得多  
    十六进制是一种更紧凑的表示方法，它将四个二进制位（一个十六进制位）组合在一起，使得大的二进制数更容易阅读和理解。  
2. 常用的定点数编码方式有哪几种？各自代表什么信息?  
    原码：直观表示数值的正负大小，但不适合计算机加减运算 /常用来表示浮点数的尾数  
    反码：用于表示数值正负，也不适合加减运算 /在求补码的过程中会用到反码，纯粹是为了硬件容易实现  
    补码：广泛用于计算机的加减法 /用来表示定点整数  
    移码：常用于浮点数中的指数部分，便于指数的加减法  
3. 为什么现代计算机中大多采用补码表示带符号整数？  
    补码运算可以实现加减运算的统一，可以简化硬件电路的复杂度，用同一套硬件电路来实现加减运算，成本更低  
4. 在浮点数的基数和总位数一定的情况下，浮点数的表示范围和精度分别由什么决定？两者如何相制约？  
    浮点数的范围由阶码决定，精度由尾数决定。总位数固定的情况下，增加指数位可以扩大表示范围，但这会减少尾数位，从而降低精度。相反，增加尾数位可以提高精度，但这会减少指数位，从而缩小表示范围。  
5. 为什么要对浮点数进行规格化？有哪两种规格化操作？  
    规格化有助于简化比较和运算，减少误差，提高运算效率，也便于硬件的实现。  
    操作：向左、向右规格化  

### 5

1. CPU 的基本组成和基本功能各是什么？  
    CPU 的基本组成是数据通路和控制器，数据通路中包含组合逻辑单元和存储信息的状态单元；  
    CPU 的基本功能是周而复始地执行指令，并处理异常和中断；
2. 取指令部件的功能是什么？  
    从 PC 取出数据到 IR，为后续指令解码、步骤执行提供基础。
3. 控制器的功能是什么  
    控制单元的作用是对取出的指令进行译码，与指令执行得到的条件码或当前的机器状态、时序信号等组合，生成对数据通路进行控制的控制信号
4. 单周期处理器的CPI是多少？时钟周期如何确定？为什么单周期处理器性能差？  
    单周期处理器中，所有的指令的取出并执行都在一个时钟周期内完成，所以CPI=1；取最复杂的一条指令所用的指令周期为一个时钟周期；正是因为时钟周期取最复杂的指令所用的指令周期，因而远远大于许多指令实际上所需要的执行时间，受时钟周期宽度的影响，性能低下。
5. 硬连线控制器的特点是什么？  
    需要确定每一条指令会在什么阶段什么条件下用到什么微操作，指令越多，设计和实现就越复杂，一般用于 RISC；如果需要扩充一条新的指令，则控制器的设计就需要大改，扩充指令难度大；由纯硬件实现控制，执行速度很快，微操作控制信号由组合逻辑电路即时产生
6. 微程序控制器的特点是什么？  
    机器指令的执行过程用微程序控制，具有很大的灵活性，便于指令系统的变更、修改和扩充。微程序相对固定，通常不放在主存中，而是利用工作速度较高的ROM存放，从而缩短微程序的运行时间。缺点是，它比相同或者相近指令系统的硬布线控制器慢。
7. 为什么CISC大多采用微程序控制器，RISC大多采用硬连线控制器  
    因为RISC为精简指令集，指令数较少，使用硬布线控制器可以使得执行速度很快。CISC为复杂指令集，指令数较多，虽然硬布线控制器速度快，但是如果在CISC上使用硬布线控制器，会使结构庞杂，实现困难，维护不易，扩充和修改指令相当困难，甚至指令集过于复杂时，不能够使用硬布线控制器实现；而微程序设计思想大大降低了控制器的复杂性，灵活度高，适用于CISC，缺点就是速度相对硬布线控制器来说比较慢。

### 6

8. 控制存储器与主存有什么区别？  
    控制存储器 CS，存放的是所有指令对应的微程序，里面的信息称为微代码，采用ROM构成，速度比主存更快，只能被CPU间接访问。而主存一般采用SRAM，是计算机存放程序和数据的主要设备，能够被CPU直接访问，并且主存相对于控存来说容量大得多。  
1. 流水线方式下，一条指令的执行时间缩短了吗？程序的执行时间缩短了吗？
    一条指令执行的时间不能被缩短，但程序的执行时间缩短了，因为对于整个程序来说，流水线方式可以大大增加指令执行的吞吐率。
2. 具有什么特征的指令集易于实现指令流水线？
    指令长度应该一致	有利于简化取指令和指令译码操作  
    指令格式应该尽量规整，保证源寄存器的位置相同	有利于在指令未译码时就可取寄存器操作数  
    采用装入/存储型指令风格	有利于减少操作步骤，规整流水线  
    数据和指令在存储器中要对齐存放	有利于减少访存次数，使所需的数据在一个流水段内就能从存储器得到  
    总之，规整、简单和一致等特性有利于指令的流水线执行	
3. 为什么要在各流水段之间加寄存器？各流水段寄存器的宽度是否一样？为什么？
    可以存储数据，处理数据冒险，提高吞吐量，简化控制逻辑。不一样。因为流水线寄存器的宽度是一个设计权衡，需要根据处理器的性能目标、硬件资源和兼容性要求来确定。  
4. 你能列出哪几种流水线被阻塞的情况？  
    数据冒险、结构冒险、控制冒险、资源冲突、流水线泄漏  
5. 数据冒险的解决方法有哪些？
	- 软件方法
	    插入空指令
	    调整程序顺序，使相关性在流水线中消失
	- 硬件方法
	    插入气泡
	    数据旁路技术

### 8

1. 什么是I/O接口？I/O接口的基本功能有哪些？  
    是计算机系统中用于连接外部设备和中央处理器（CPU）的硬件组件。它允许数据在计算机内部和外部设备之间传输。  
    I/O 接口的基本功能包括：
    1.	数据传输：实现计算机与外部设备之间的数据输入和输出。
    2.	信号转换：将计算机内部使用的逻辑信号转换为外部设备能够识别和处理的信号，反之亦然。
    3.	设备控制：通过发送控制信号来管理外部设备的操作，如启动、停止、重置等。
    4.	数据缓冲：在数据传输过程中，I/O接口可能会使用缓冲区来暂时存储数据，以解决数据传输速度不匹配的问题。
    5.	错误检测：在数据传输过程中，I/O接口可以检测错误，如奇偶校验错误、溢出错误等，并采取相应的措施。
    6.	设备选择：在多个外部设备连接到同一I/O接口时，接口需要能够选择特定的设备进行通信。
    7.	数据格式转换：将外部设备的数据格式转换为计算机内部可以处理的格式，或者将计算机的数据格式转换为外部设备可以接收的格式。
    8.	同步与异步通信：支持同步通信（数据传输与时钟信号同步）和异步通信（数据传输不依赖于时钟信号）。
    9.	中断处理：当外部设备需要CPU注意时，I/O接口可以生成中断信号，通知CPU进行相应的处理。
    10.	电源管理：为外部设备提供电源，或者管理设备与计算机之间的电源连接。
2. CPU 如何进行设备的寻址？  
    CPU对设备进行访问是通过读写外设上的各类寄存器实现的，也称为I/O端口，对I/O端口进行编址的方式分为独立编址和统一编址；独立编址的外设需要CPU使用特定的IO指令来访问外设；统一编址的方式中用统一的访存指令就可以进行访问，并且无需专门的保护机制，给编程提供了很大的灵活性。  
    IO 端口寻址 CPU使用特殊的指令（例如IN和OUT指令在x86架构中）来访问这些端口，每个端口都有一个唯一的地址。  
    内存映射I/O 内存映射I/O将外围设备的寄存器映射到系统的内存地址空间中。CPU可以像访问普通内存一样访问这些地址，使用标准的读写指令来与设备交互。这种方式简化了编程模型，因为所有的访问都可以使用相同的指令集，但它可能会占用一部分内存地址空间。
3. I/O 端口的编址方式有哪两种？各有何特点？  
    有独立编址和统一编址两种；  
    独立编址是指I/O端口与主存分开进行编址，访问I/O端口时需要使用专门的命令来访问，灵活性较差，优点是译码简单，访存速度快，逻辑清晰，便于检查和维护；  
    统一编址是指将IO端口与主存一起进行编址，共享相同的地址空间，可以用同一套访存指令去访问，提高程序设计灵活性，但占用了内存空间一部分，执行时间也相对较慢。 
4. 什么是DMA方式？  
    直接存储器存取；用专门的DMA接口硬件来控制外设与主存间的直接数据交换，数据不通过CPU。通常把专门用来控制总线进行DMA传送的接口硬件称为DMA控制器。在进行DMA传送时，CPU让出总线控制权，由DMA控制器控制总线，通过“窃取”一个主存存储周期完成和主存之间的一次数据交换，或独占若干存储周期完成一批的数据交换。
5. 什么是中断控制I/O方式？说明工作原理。  
    中断控制I/O的基本思想是，当进程P1需要进行一个I/O操作时，他会先启动外设进行第一个数据的IO操作，并挂起执行IO的进程P1使其被阻塞，然后从就绪队列中选择另一个进程P2执行，此时，外设在准备P1所需的数据，CPU在执行P2，因此CPU和外设并行工作。当外设完成IO操作，便向CPU发出中断请求。CPU响应请求后，就中止正在执行的用户进程P2，转入一个中断服务程序，在中断服务程序中再启动随后数据的IO传送任务。中断服务程序执行后，返回原被中止的用户进程P2的断点处继续执行，此时CPU和外设又开始并行工作  

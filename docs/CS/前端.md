# HTML

## 基础知识

### 定义

回流  
当render tree中的一部分或全部因为元素的规模尺寸、布局、隐藏等改变时，浏览器重新渲染部分DOM或全部DOM的过程。回流也被称为重排，其实从字面上来看，重排更容易让人形象易懂（即重新排版整个页面）。

重绘  
当页面元素样式改变不影响元素在文档流中的位置时（如background-color，border-color，visibility），浏览器只会将新样式赋予元素并进行重新绘制操作。

### DOM

Document Object Model, 文档对象模型  

- 元素（element）  
  文档中的所有标签都是元素，元素可以看成是对象  
- 节点（node）  
  文档中所有的内容都是节点：标签，属性，文本  
- 文档（document）  
  一个页面就是一个文档  

文档包含节点，节点包含元素  

#### 对 DOM 树的操作

```js

// 取：  
document.getElementById();

// 获取节点所有属性  
node.attributes  

// 获取节点所有子元素  
node.childNodes  

// 增：  
let a = createElement('a')
document.body.append(a)

// 删：
document.body.removeChild(div);

```

##### 改变节点中的文本值

##### innerHTML、innerText、textContent

- innerHTML  
  表示所有 HTML  
  Element 对象的属性  
- innerText  
  表示所有文本内容  
  HTMLElement 对象的属性  
- textContent  
  返回的是字符串或 null  
  修改该属性会删除其他全部节点  
  Node 对象的属性  

innerText会触发回流，但是textContent可能不会触发回流，所以实际应用中，使用textContent性能更佳  
innerTTML会返回HTML文本，textContent的内容不会解析成HTML文本，使用textContent可以防止XSS攻击  

## 面试

### URL 到 页面渲染

1. URL 解析  
  1. 提取协议、主机名、端口号、路径等信息。  
  2. DNS 查询  
2. 建立 TCP 连接  
3. 发送 HTTP 请求和服务器处理  
4. 浏览器解析与渲染流程  
5. JavaScript 执行与交互  
6. 断开 TCP 连接  

### 怎么渲染 http 文件到页面上

1. 构建 DOM 树  
2. 构建 CSSOM 树  
3. 生成渲染树  
4. 布局与绘制  

### 白屏问题的常见原因和排查

1. 网络和资源加载  
  页面资源未加载或加载超时  
  排查：  
    控制台打印错误、网络面板  
    测试CDN与资源路径  
    优化加载策略  
2. 前端代码错误  
3. 服务器与接口问题
4. 浏览器兼容与缓存问题  
5. 第三方服务异常

### js 的加载方式

同步加载  
  浏览器遇到 `<script>` 标签时，会暂停 HTML 解析，下载并执行脚本，完成后才继续渲染页面。  

异步加载
  defer  
  async  
  动态创建  

模块化加载  
  type="module"  

延迟加载  
  import()

### JavaScript 加载冲突

- 命名空间污染导致冲突  
  - 变量、函数名重复  
  - 第三方库冲突  
- 事件绑定冲突  
- 资源加载顺序问题  
- 浏览器兼容性冲突  
- DOM 和资源操作冲突  

### src 和 href

src 是要加载资源的路径  
href 是指定超链接目标地址 或 定义文档与外部资源的关联  

### 性能优化

#### SRC

- 异步加载脚本：  
  - async 属性能让脚本与 HTML 解析并行加载，加载完后立即执行。  
  - defer 属性能让脚本与 HTML 解析并行加载，但执行顺序与页面解析顺序一致，且在解析完成后执行。  
- 图片懒加载：  
  loading="lazy"  
- CDN  
- 资源压缩  

#### href

- 预加载关键资源  
  使用`<link rel='preload' href='style.css' as='style'>`指定关键资源，提高页面加载速度。  
- 防止阻塞渲染  
  将非关键 CSS 文件标记为延迟加载，`media='print' onload="this.media='all';"`  
- 动态加载  
  使用 JS 动态创建 `<link>` 标签加载非必要资源

### 跨域

跨域（Cross-Origin）指浏览器限制从某个域名（源）加载的脚本与另一个域名的资源进行交互的行为。  
核心限制来源于浏览器的同源策略（Same-Origin Policy），该策略要求以下三者必须完全一致才视为“同源”：
- 协议（如 http vs https）  
- 域名（如 a.com vs b.com）  
- 端口（如 80 vs 8080）  
若三者任一不同，则触发跨域限制，表现为无法读取其他源的 Cookie、LocalStorage，或通过 AJAX 发送请求等  

#### 解决方法

- JSONP（JSON with Padding）
  利用 `<script>` 标签的 src 属性无跨域限制的特性，通过动态创建标签发送 GET 请求，服务器返回数据包裹在回调函数中执行。
- CORS(跨域资源共享)  
  通过服务器设置 HTTP 响应头，明确声明允许跨域访问的源、方法和头部信息。  
- 反向代理（Nginx/HTTP Proxy）  
  通过服务器代理转发请求，如配置 Nginx 将 /api 路径代理到目标服务器，绕过浏览器限制。  
- WebSocket  
  基于 WebSocket 协议的双向通信，不受同源策略限制。  
- postMessage  
  允许不同源的窗口间通过 window.postMessage 安全通信，常用于 iframe 跨域。  

### preload 和 prefetch

web 加载原语(如<link rel= preload > & <link rel= prefetch >)  

- preload 是一个声明式 fetch，可以强制浏览器在不阻塞 document 的 onload 事件的情况下请求资源。  
- Prefetch 告诉浏览器这个资源将来可能需要，但是什么时间加载这个资源是由浏览器来决定的。  

### Polyfill

Polyfill 是一块代码（通常是 Web 上的 JavaScript），用来为旧浏览器提供它没有原生支持的较新的功能。  

#### 打补丁的三种方法

https://zhuanlan.zhihu.com/p/71640183

1. 手动打补丁  
2. 根据覆盖率自动打补丁
3. 根据浏览器特性，动态打补丁

# CSS

## position

[position](https://developer.mozilla.org/zh-CN/docs/Web/CSS/position)

position — 作为css属性三巨头（position、display、float）之一，它的作用是用来决定元素在文档中的定位方式。其属性值有五种，分别是  
- static（正常定位）  
    该关键字指定元素使用正常的布局行为，即元素在文档常规流中当前的布局位置。此时 top, right, bottom, left 和 z-index 属性无效。  
- relative（相对定位）  
    该关键字下，元素先放置在未添加定位时的位置，再在不改变页面布局的前提下调整元素位置（因此会在此元素未添加定位时所在位置留下空白）。position:relative 对 table-*-group, table-row, table-column, table-cell, table-caption 元素无效。  
- absolute（绝对定位）  
    元素会被移出正常文档流，并不为元素预留空间，通过指定元素相对于最近的非 static 定位祖先元素的偏移，来确定元素位置。绝对定位的元素可以设置外边距（margins），且不会与其他边距合并。
- fixed（固定定位）  
    元素会被移出正常文档流，并不为元素预留空间，而是通过指定元素相对于屏幕视口（viewport）的位置来指定元素位置。元素的位置在屏幕滚动时不会改变。打印时，元素会出现在的每页的固定位置。fixed 属性会创建新的层叠上下文。当元素祖先的 transform、perspective、filter 或 backdrop-filter 属性非 none 时，容器由视口改为该祖先。  
    固定定位与绝对定位相似，但元素的包含块为 viewport 视口。该定位方式常用于创建在滚动屏幕时仍固定在相同位置的元素。  
- sticky（粘性定位）  
    元素根据正常文档流进行定位，然后相对它的最近滚动祖先（nearest scrolling ancestor）和 containing block（最近块级祖先 nearest block-level ancestor），包括 table-related 元素，基于 top、right、bottom 和 left 的值进行偏移。偏移值不会影响任何其他元素的位置。 该值总是创建一个新的层叠上下文（stacking context）。注意，一个 sticky 元素会“固定”在离它最近的一个拥有“滚动机制”的祖先上（当该祖先的 overflow 是 hidden、scroll、auto 或 overlay 时），即便这个祖先不是最近的真实可滚动祖先。  
    粘性定位可以被认为是相对定位和固定定位的混合。元素在跨越特定阈值前为相对定位，之后为固定定位。  

## display

用于定义元素的显示（如何在页面上布局和显示）  
| 属性值               | 作用描述                                                                 |
|-----------------------|--------------------------------------------------------------------------|
| **`block`**           | 元素显示为块级元素，独占一行，可设置宽高。默认宽度撑满父容器。            |
| **`inline`**          | 元素显示为行内元素，不换行，不可设置宽高（宽高由内容决定）。              |
| **`inline-block`**    | 元素显示为行内块，可设置宽高，但不会独占一行（兼具块级和行内特性）。       |
| **`none`**            | 元素不显示，且不占据文档流空间（完全隐藏）。                              |
| **`flex`**            | 元素变为弹性容器，子元素可通过弹性布局控制排列方式（一维布局）。           |
| **`grid`**            | 元素变为网格容器，子元素可通过网格布局控制行列分布（二维布局）。           |
| **`table`**           | 元素显示为表格（类似 `<table>`），可配合 `table-row`、`table-cell` 使用。 |
| **`list-item`**       | 元素显示为列表项（类似 `<li>`），通常与 `list-style` 属性配合使用。        |
| **`inherit`**         | 继承父元素的 `display` 属性值。                                          |
| **`initial`**         | 设置为默认值（通常是 `inline`）。                                         |
| **`contents`**        | 元素自身不渲染，但其子元素提升到父级层级（常用于隐藏容器但保留内容）。      |

### flex

```css
display: flex;

/* 主轴方向 */
  flex-direction: row;            /* 默认值：从左到右 */
  /* flex-direction: row-reverse; */ /* 从右到左 */
  /* flex-direction: column; */      /* 从上到下 */
  /* flex-direction: column-reverse; */ /* 从下到上 */

/* 换行方式 */
flex-wrap: nowrap;

/* 主轴对齐方式 */
jusity-content: flex-start;

/* 交叉轴对齐方式 */
align-items: stretch;

/* 多行对齐方式 */
align-content: stretch;

```

### grid

## float

## 属性

可继承属性
- color
- font
- letter-spacing
- line
- text

不可继承属性
- background
- border
- display
- position
- float
- width
- left
- z-index

inherit 关键字可以明确让某个属性继承其父元素的值  
initial 关键字把属性设置为其默认值  
unset 对于可继承属性 inherit；不可继承属性 = initial  

## 选择器

| 选择器类型            | 语法示例                     | 作用描述                                                                 | 优先级权重（数值） |
|-----------------------|-----------------------------|--------------------------------------------------------------------------|--------------------|
| **元素选择器**        | `div`                      | 选择所有指定 HTML 标签的元素（如所有 `<div>`）。                         | 1                  |
| **类选择器**          | `.class-name`              | 选择所有具有指定类名的元素（如 `<div class="class-name">`）。           | 10                 |
| **ID 选择器**         | `#id-name`                 | 选择具有指定 ID 的唯一元素（如 `<div id="id-name">`）。                 | 100                |
| **属性选择器**        | `[type="text"]`            | 选择具有指定属性和值的元素（如 `<input type="text">`）。                | 10                 |
| **伪类选择器**        | `:hover`                   | 选择元素的特定状态（如鼠标悬停时的状态）。                               | 10                 |
| **伪元素选择器**      | `::before`                 | 选择元素的特定部分（如在元素前插入内容）。                               | 1                  |
| **通配符选择器**      | `*`                        | 选择页面中的所有元素。                                                   | 0                  |
| **后代选择器**        | `div p`                    | 选择某元素内部的所有指定后代元素（如 `<div>` 内的所有 `<p>`）。          | 权重累加（如 1+1） |
| **子元素选择器**      | `div > p`                  | 选择某元素的直接子元素（如 `<div>` 的直接子元素 `<p>`）。               | 权重累加           |
| **相邻兄弟选择器**    | `div + p`                  | 选择紧接在某元素后的第一个兄弟元素（如 `<div>` 后的第一个 `<p>`）。     | 权重累加           |
| **通用兄弟选择器**    | `div ~ p`                  | 选择某元素后的所有兄弟元素（如 `<div>` 后的所有 `<p>`）。               | 权重累加           |
| **群组选择器**        | `div, .class, #id`         | 同时选择多个元素（如所有 `<div>`、类名 `.class` 和 ID `#id` 的元素）。  | 独立计算，取最高值 |
| **内联样式**          | `<div style="color: red">` | 直接在 HTML 标签内写的样式。                                             | 1000               |
| **`!important`**      | `color: red !important;`   | 强制覆盖其他样式规则（慎用）。                                           | 优先级最高         |

## 优先级

- 内联样式（HTML 元素上的 style）
    每个加 1000 分  
- ID 选择器（#id）
    每个加 100 分  
- 类选择器、属性选择器、伪类选择器（.class、[attr=value]、:hover）  
    每个加 10 分  
- 元素选择器和伪元素选择器（div、::before）  
    每个加 1 分  
- 通配符选择器、后代选择器、子选择器等（*、div p、div > p）  

优先级相同，后出现的样式生效  

## link 和 @import 引用 CSS 的区别

link  
- 在 `<head>` 部分使用
- 在网页加载时立即加载样式表
- 并行进行，性能好  
- 可通过 JavaScript 操作 DOM

@import
- 在 CSS 文件或`<style>`标签内使用
- 在加载包含它的 CSS 文件后加载  
- 加载顺序依赖，速度慢  
- 不易通过 JavaScript 操作  

## 面试

### BFC

Block Formatting Context，块级格式化上下文  

### Canvas 和 SVG 有什么区别

又是用于在网页上绘制图形的技术  
Canvas 是基于像素的即时绘制技术，适合频繁更新和复杂动画  
SVG 是基于矢量的图形格式，适合需要无损缩放和高分辨率的静态图形  

### CSS3 新特性

布局：  
- 容器查询
  允许根据容器尺寸而非视口调整元素样式，实现组件级响应式设计。  
  `@container (width > 600px) { ... }`  
- 子网格与命名区域  
  子网格：嵌套网格可继承父级对齐方式，简化复杂布局代码。  
  命名区域：通过语义化名称定义网格区域，如`grid-template-areas: "header main sidebar"`，提升代码可读性。  
- 动态视口单位  
  新增`dvh`（动态视口高度）、`lvc`（逻辑视口单位）等，适配折叠屏、刘海屏等异形设备  

颜色与视觉效果：  
- 广色域与 HDR 支持  
  新增`oklch()`、`color(display-p3)`等函数，支持P3色域和HDR显示设备。  
  HWB颜色模型：hwb(0 0% 30%)直接定义色调、白度与黑度，更符合人类直觉。  
- 颜色混合与函数扩展  
  `color-mix()`:混合两种颜色并控制比例，如color-mix(in srgb, red 40%, blue)  
  `@property`：注册自定义颜色属性，支持动画与类型验证  
- 背景滤镜  
  对元素背景区域应用模糊、对比度等滤镜，增强视觉层次感。  

交互与动画：  
- 滚动驱动动画（Scroll-Driven Animations）  
  动画进度与滚动深度绑定，如animation-timeline: scroll()实现视差效果  
- 视图过渡  
  跨文档或单页应用切换时生成平滑动画，支持多页面无缝跳转  
    语法：`::view-transition-old`和`::view-transition-new`控制过渡状态   
- CSS Toggles
  无JavaScript实现状态切换，如暗黑模式：`toggle-root: theme [light dark]`  

响应式与逻辑控制：  
- 逻辑属性  
- `:has()` 选择器  
- 媒体查询扩展  

作用域与模块化  
- `@scope`规则  
- 原生嵌套语法  

# JavaScript

https://www.bookstack.cn/read/javascript-tutorial/README.md

## 简单知识

### 特点

单线程、非阻塞异步处理机制

### 数据类型

原始类型  
- 数值（number）：整数和小数（比如1和3.14）
- 字符串（string）：文本（比如Hello World）。
- 布尔值（boolean）：表示真伪的两个特殊值，即true（真）和false（假）
- undefined：表示“未定义”或不存在，变量声明了，但没有赋值  
- null：表示空值，即此处的值为空，空对象引用。
- symbol：唯一且不可变的值，用于对象属性的唯一标识。  
- bigint：表示任意精度的大整数  
特点
- 原始类型存储在 stack 中，值直接保存在变量访问的位置  
- 复制的是值本身  

引用类型  
- 狭义的对象（object）
- 数组（array）
- 函数（function）
特点
- 引用类型存储在 heap 中，变量保存的是实际对象的引用（指针）  
- 复制的是引用，多个变量引用同一对象时，一个变量的修改会影响其他变量。

### == 和 ===

JavaScript 中的 ==（宽松相等）和 ===（严格相等）是两种不同的比较运算符，核心区别在于 是否进行类型转换 以及 对特殊值的处理规则

### 执行上下文

- 全局执行上下文：全局执行环境是最外围的一个执行环境，在浏览器的全局对象是 window, this指向这个对象。  
- 函数执行上下文：可以有无数个，函数被调用的时候会被创建。每次调用函数都会创建一个新的执行上下文。  
- eval执行上下文，很少用。  

每个执行上下文，都有三个重要属性：  
- 变量对象 (variable object, VO)  
    每个执行环境都有一个与之关联的变量对象，环境中定义的所有变量和函数都保存在这个对象中。虽然我们编写的代码无法访问这个对象，但解析器在处理数据时会在后台使用它。  
- 作用域链（scope chain）  
    当代码在一个环境中执行时，会创建变量对象的一个作用域链。作用域链的用途，是保证对执行环境有权访问的所有变量和函数的有序访问。  
- this  
    普通函数指向函数的调用者：有个简便的方法就是看函数前面有没有点，如果有点，那么就指向点前面的那个值;  
    箭头函数指向函数所在的所用域：注意理解作用域，只有函数的{}构成作用域，对象的{}以及 if(){}都不构成作用域;  

### 回收机制

垃圾回收（Garbage Collection, GC）  
JavaScript 自动管理内存的核心机制，通过识别和释放不再使用的内存空间，防止内存泄漏并提升性能。  
可达性（Reachability）：从根对象（如全局变量、活动函数的局部变量等）出发，通过引用链无法访问的对象会被视为垃圾。  

回收算法
- 标记-清除（Mark-and-Sweep）  
  原理：  
    标记阶段：从根对象出发，递归遍历所有可达对象并标记为活动。  
    清除阶段：遍历堆内存，释放未被标记的对象。  
  优点：  
    能处理循环引用问题  
  缺点：  
    可能产生内存碎片，清除时需要暂停程序。  
- 引用计数（Reference Counting）  
  原理：  
    每个对象维护引用计数器，引用数量为 0 时回收。  
  优点：  
    可即时回收内存。  
  缺点：  
    无法解决循环引用问题。  

#### 现代 JS 引擎的优化策略

1. 分代收集（Generational Collection）  
  分代假设：大多数对象生命周期短，少数长期存活。  
    新生代：存放短命对象，使用 复制算法（如 V8 的 Scavenge）快速回收。  
    老生代：存放长存对象，采用 标记-清除 + 标记-整理（减少碎片）。  
2. 增量标记（Incremental Marking）  
  将标记过程拆分为多个小步骤，穿插在主线程任务中执行，减少程序停顿时间。  
3. 闲时收集（Idle-Time Collection）  
  在 CPU 空闲时执行垃圾回收，减少对主线程性能的影响  

### 作用域

- 全局作用域
- 局部作用域
- 函数作用域
- 块作用域
  解决了es5存在的2个重要问题  
    - 内层变量覆盖外层变量  
    - 循环计数变量泄露为全局变量  

### 定义变量的三种方式

let
    块级作用域  
    变量提升但未初始化  
    需要重新赋值的变量  
const
    块级作用域  
    变量提升但未初始化  
    声明常量或引用类型，避免意外修改  
var
    函数级作用域  
    提升初始化为 undefined  
    不推荐使用  

### 闭包

- 闭包是指有权访问另一个函数作用域中变量的函数。  
- 闭包通常用来创建内部变量，使得 这些变量不能被外部随意修改，同时又可以通过指定的接口来操作。  
- 由于闭包会保持对外部作用域的引用，所以它的内存不会被自动回收，容易导致内存泄漏。  

优点：  
- 保护变量
- 延长变量生命周期  
- 实现模块化  
- 保持状态  
 
缺点：  
- 内存占用  
- 性能损耗  
  涉及作用域链查找过程，会带来一定性能损耗。  

特性：  
- 函数嵌套  
  闭包的实现依赖于函数嵌套，即在一个函数内部定义另一个函数。  
- 记忆外部变量  
- 延长作用域链  
- 返回函数  

#### 应用

- 自执行函数  
- 防抖  
- 节流
- 函数柯里化  
  函数柯里化（Currying）是一种将多个参数的函数转换为一系列接受单个参数的函数的过程。  
- 链式调用  
- 迭代器  
- 发布-订阅模式  

#### 问题

闭包造成的内存泄漏怎么解决？  
  闭包中的内存泄漏指的是在闭包函数中，由于对外部变量的引用而导致这些变量无法被垃圾回收机制释放的情况。当一个函数内部定义了一个闭包，并且这个闭包引用了外部变量时，如果这个闭包被其他地方持有，就会导致外部变量无法被正常释放，从而造成内存泄漏。 解决闭包中的内存泄漏问题通常需要注意解除外部变量和闭包函数的引用，以及解绑函数本身的引用，使得闭包中引用的外部变量和闭包函数能够被垃圾回收机制释放。  

```js

function createClosure() {
  let value = 'Hello';
​
  // 闭包函数
  var closure = function() {
    console.log(value);
  };
​
  // 解绑定闭包函数，并释放资源
  var releaseClosure = function() {
    value = null; // 解除外部变量的引用
    closure = null; // 解除闭包函数的引用
    releaseClosure = null; // 解除解绑函数的引用
  };
​
  // 返回闭包函数和解绑函数
  return {
    closure,
    releaseClosure
  };
}
​
// 创建闭包
var closureObj = createClosure();
​
// 调用闭包函数
closureObj.closure(); // 输出：Hello
​
// 解绑闭包并释放资源
closureObj.releaseClosure();
​
// 尝试调用闭包函数，此时已解绑，不再引用外部变量
closureObj.closure(); // 输出：null

```

#### 防抖  

防抖的核心是 延迟执行：高频事件触发后，若在指定时间间隔内再次触发，则重置计时器；只有最后一次触发后的等待时间结束，才会执行目标函数。  

```js

// 基础版本
function debounce(func, delay) {
  let timer;
  return function(...args) {
    clearTimeout(timer);
    timer = setTimeout(() => {
      func.apply(this, args);
    }, delay);
  };
}

//支持立即执行版本
function debounce(func, delay, immediate = false) {
  let timer;
  return function(...args) {
    const callNow = immediate && !timer;
    clearTimeout(timer);
    timer = setTimeout(() => {
      if (!immediate) func.apply(this, args);
      timer = null;
    }, delay);
    if (callNow) func.apply(this, args);
  };
}
```

应用场景：  
- 搜索框输入联想（用户停止输入后发送请求）
- 窗口大小调整后重新布局
- 表单验证（停止输入后统一校验）

#### 节流  

节流的本质是 频率限制：无论事件触发多频繁，在固定时间间隔内最多执行一次目标函数。  

```js

// 时间戳版（立即执行）
function throttle(func, limit) {
  let last = 0;
  return function(...args) {
    const now = Date.now();
    if (now - last >= limit) {
      func.apply(this, args);
      last = now;
    }
  };
}

// 定时器版（延迟执行）
function throttle(func, limit) {
  let timer;
  return function(...args) {
    if (!timer) {
      timer = setTimeout(() => {
        func.apply(this, args);
        timer = null;
      }, limit);
    }
  };
}

// 优化版本（结合首次和最后一次执行）
function throttle(func, limit, { leading = true, trailing = true }) {
  let last = 0, timer;
  return function(...args) {
    const now = Date.now();
    if (leading && now - last >= limit) {
      func.apply(this, args);
      last = now;
    } else if (trailing && !timer) {
      timer = setTimeout(() => {
        if (trailing) func.apply(this, args);
        timer = null;
        last = now;
      }, limit - (now - last));
    }
  };
}

```

### 事件循环

JavaScript 为了避免复杂处理（事件锁），使用了单线程。  
要在单线程中实现非阻塞IO，就要使用事件循环来实现。JS引擎本身不实现事件循环机制，是通过宿主（浏览器、nodejs）实现的。  
浏览器和 nodejs 中的事件循环有一定的区别  

- 执行栈  
  同步代码的执行，按照执行顺序添加到执行栈中  
- 事件队列  
  异步代码则会将事件挂起，等待返回结果后放到事件队列中。等主线程空闲，取出事件对应的回调放入执行栈中执行。  
- 宏任务和微任务  
  优先级不同，不同的异步任务被分为宏任务和微任务  

- 先执行宏任务，然后再执行当前宏任务产生的微任务，再执行宏任务

| **对比项**           | **浏览器事件循环**                                                                 | **Node.js事件循环**                                                                 |
|----------------------|-----------------------------------------------------------------------------------|-------------------------------------------------------------------------------------|
| **阶段划分**          | 无明确阶段划分，仅分宏任务队列和微任务队列                           | 分为6个阶段：Timers → Pending → Poll → Check → Close            |
| **宏任务类型**        | `setTimeout`、`setInterval`、I/O操作、UI渲染、脚本执行              | `setTimeout`、`setInterval`、`setImmediate`、I/O操作、关闭回调 |
| **微任务类型**        | `Promise.then`、`MutationObserver`、`queueMicrotask`               | `Promise.then`、`process.nextTick`                                    |
| **执行顺序**          | 每个宏任务结束后立即执行所有微任务                                  | 每个阶段执行完当前队列的**全部宏任务**后，再执行微任务（旧版本）；<br>Node 11+后每个宏任务后执行微任务 |
| **I/O处理机制**       | 由浏览器多线程（网络线程、渲染线程等）处理，回调推入任务队列         | 由libuv库通过线程池处理异步I/O，完成后回调推入事件队列               |
| **定时器优先级**      | `setTimeout`回调在延迟结束后进入宏任务队列                                | `setImmediate`在Check阶段执行，`setTimeout`在Timers阶段执行，I/O中`setImmediate`优先 |
| **渲染时机**          | 微任务执行后可能触发UI渲染                                           | 无渲染阶段，主要用于服务端                                            |
| **线程模型**          | 单主线程（JS执行）+ 多辅助线程（网络、渲染等）                             | 单主线程（JS执行）+ libuv线程池（I/O处理）                            |

#### 细节知识

Node.js中process.nextTick优先级高于微任务  
requestAnimationFrame 既不是宏任务也不是微任务，属于浏览器渲染前的回调，执行时机在微任务之后、UI渲染之前。

Timers 阶段  
  处理 setTimeout 和 setInterval 回调  
Check 阶段  
  处理 setImmediate 阶段  

#### 应用问题

如何优化长时间任务对时间循环的影响  
- 使用 Web Worker 拆分计算密集型任务  
- 利用 setTimeout 或 requestldilCallback 分片执行  

Promise.all 和 Promise.race 的实现原理及区别  
- Promise.all 等待所有 Promise 完成  
- Promise.race 以第一个完成/拒绝的 Promise 为准  


### ES6 有哪些新特性

1. let、const
2. 箭头函数
3. 模板字符串
4. 解构赋值
5. 默认参数
6. 扩展运算符
7. 类与模块
8. Promise
9. Symbol 和迭代器
10. 新的数据结构：Map、Set
11. 对象属性简写，属性方法简写

### 原型链

https://segmentfault.com/a/1190000042725370

原型（prototype）  
- 对象有__proto__属性，函数有__proto__属性，数组也有__proto__属性，只要是引用类型，就有__proto__属性，指向其原型。  
- 只有函数有prototype属性，指向new操作符加调用该函数创建的对象实例的原型对象。

原型链的形成  
- 当访问对象的属性时，若对象自身没有该属性，会通过 [[Prototype]] 逐级向上查找，直到找到或到达链的顶端 Object.prototype（其 [[Prototype]] 为 null）  
- person1.toString() 的查找路径为：person1 → Person.prototype → Object.prototype → null  

### ajax-axios-fetch

#### Ajax

Asynchronous JavaScript and XML，异步的 JS 和 XML  
AJAX是一种基于XMLHttpRequest（XHR）对象的异步通信技术，允许浏览器与服务器交换数据并局部更新页面，而无需刷新整个页面。其核心原理是通过JavaScript发起HTTP请求，处理响应数据后，使用DOM操作动态更新网页内容。  

1. 创建 XMLHttpRequest 对象  
2. 配置请求
3. 设置回调函数
4. 发送请求
5. 处理响应数据

#### Axios

Axios是一个基于Promise的HTTP客户端库，封装了XHR对象，支持浏览器和Node.js环境。它简化了请求配置，并提供了拦截器、自动JSON转换、取消请求等高级功能  

1. 发送请求  
2. 响应数据  
3. 请求和响应拦截器  
4. 错误处理

#### Fetch

现代的网络请求 API，用于在浏览器中发起 HTTP 请求。它是 XMLHttpRequest 的升级版，提供了更简洁和强大的接口，并且原生支持 HTTP/2的一些特性  

优点：  
- 原生支持 Promise
- 提供了请求和响应对象（Request、Response）
- 支持 HTTP/2 流式处理  
    通过 Response.body 获取到原始的响应流  

不足：  
- 不会自动携带 cookie  
- 无法原生取消请求
- 无法原生监控请求进度  

### 深拷贝和浅拷贝

浅拷贝：  
只复制对象的第一层属性，如果属性是 引用类型（如对象、数组），则拷贝的是 引用地址，而不是实际的值。  

- Object.assign()
- 展开运算符...
- Array.prototype.slice()

深拷贝：  
递归复制对象的所有层级，包括嵌套的引用类型，生成一个 完全独立的新对象。  

- JSON.parse(JSON.stringify(obj))
- 递归  
- structuredClone()

### 常用函数、方法、对象

#### Array

##### 数组常用方法表格总结

| 方法名               | 作用                                  | 返回值                      | 示例                                      |
|----------------------|-------------------------------------|----------------------------|------------------------------------------|
| **`push(item)`**      | 在数组末尾添加元素                   | 新数组长度                  | `arr.push(5);` → 长度+1                  |
| **`pop()`**           | 删除并返回最后一个元素               | 被删除元素                  | `const last = arr.pop();`                |
| **`unshift(item)`**   | 在数组开头添加元素                   | 新数组长度                  | `arr.unshift(0);` → 长度+1               |
| **`shift()`**         | 删除并返回第一个元素                 | 被删除元素                  | `const first = arr.shift();`             |
| **`splice(start, deleteCount, ...items)`** | 在指定位置增删/替换元素 | 被删除元素的数组            | `arr.splice(1, 1, 'a');` → 替换索引1元素 |
| **`slice(start, end)`** | 截取数组片段（不修改原数组）         | 新数组                      | `const sub = arr.slice(0, 2);`           |
| **`indexOf(item)`**   | 查找元素首次出现的索引               | 索引（未找到返回 `-1`）     | `arr.indexOf('apple');` → 0 或 -1        |
| **`find(callback)`**  | 返回满足条件的第一个元素             | 元素（未找到返回 `undefined`） | `arr.find(x => x > 5);`                 |
| **`filter(callback)`**| 返回满足条件的所有元素的新数组       | 新数组                      | `arr.filter(x => x % 2 === 0);`          |
| **`map(callback)`**   | 遍历处理元素并返回新数组             | 新数组                      | `arr.map(x => x * 2);`                   |
| **`forEach(callback)`** | 遍历执行操作（无返回值）            | `undefined`                 | `arr.forEach(x => console.log(x));`      |
| **`reduce(callback, initialValue)`** | 累加处理数组元素        | 最终累加结果                | `arr.reduce((sum, x) => sum + x, 0);`    |
| **`sort([compareFn])`** | 排序数组（默认按字符串Unicode码）   | 排序后的原数组              | `arr.sort((a, b) => a - b);`             |
| **`reverse()`**       | 反转数组元素顺序                     | 反转后的原数组              | `arr.reverse();` → `[3, 2, 1]`           |
| **`concat(arr2)`**    | 合并多个数组                         | 新数组                      | `const merged = arr1.concat(arr2);`      |
| **`join(separator)`** | 将数组转为字符串（指定分隔符）       | 字符串                      | `arr.join(', ');` → `"a, b, c"`          |
| **`includes(item)`**  | 检查是否包含某元素                   | 布尔值                      | `arr.includes('apple');` → `true/false`  |
| **`some(callback)`**  | 检查是否有至少一个元素满足条件       | 布尔值                      | `arr.some(x => x > 10);`                 |
| **`every(callback)`** | 检查是否所有元素都满足条件           | 布尔值                      | `arr.every(x => x > 0);`                 |

#### Object

| 方法名                             | 描述                                                                 | 示例                                                                 |
|----------------------------------|--------------------------------------------------------------------|--------------------------------------------------------------------|
| `Object.keys(obj)`               | 返回对象自身可枚举属性的键名数组                                       | `Object.keys({a:1, b:2})` → `["a", "b"]`                           |
| `Object.values(obj)`             | 返回对象自身可枚举属性的键值数组                                       | `Object.values({a:1, b:2})` → `[1, 2]`                            |
| `Object.entries(obj)`            | 返回对象自身可枚举属性的键值对二维数组                                   | `Object.entries({a:1, b:2})` → `[["a", 1], ["b", 2]]`              |
| `Object.assign(target, ...src)` | 合并源对象属性到目标对象（浅拷贝）                                      | `Object.assign({a:1}, {b:2})` → `{a:1, b:2}`                      |
| `Object.create(proto)`           | 创建以指定对象为原型的新对象                                           | `const obj = Object.create({name: "Alice"}); obj.name` → `"Alice"`|
| `Object.freeze(obj)`             | 冻结对象（不可修改/添加/删除属性）                                     | `Object.freeze(obj); obj.a = 2` → 修改失败                        |
| `Object.seal(obj)`               | 密封对象（不可添加/删除属性，但可修改值）                               | `Object.seal(obj); obj.a = 2` → 修改有效                          |
| `Object.is(val1, val2)`          | 严格值比较（处理 `NaN` 和 `±0`）                                     | `Object.is(NaN, NaN)` → `true`；`Object.is(0, -0)` → `false`      |
| `Object.fromEntries(entries)`    | 将键值对列表转换为对象                                               | `Object.fromEntries([["a",1], ["b",2]])` → `{a:1, b:2}`           |
| `Object.hasOwn(obj, prop)`       | 检查对象自身是否包含指定属性（ES2022新增）                             | `Object.hasOwn({a:1}, 'a')` → `true`                              |

#### Map

#### Map 常用方法

| 操作类型         | 方法/属性          | 语法示例/描述                                                                 | 来源参考 |
|------------------|--------------------|------------------------------------------------------------------------------|----------|
| **创建Map**      | `new Map()`        | `const map = new Map();` 或 `new Map([[key1, val1], [key2, val2]])` 初始化   |  |
| **添加键值对**   | `.set(key, value)` | 支持链式调用：`map.set('a', 1).set('b', 2)`                                  |  |
| **获取值**       | `.get(key)`        | `map.get('a')` → 返回对应值，不存在返回 `undefined`                         |  |
| **判断键存在**   | `.has(key)`        | `map.has('a')` → 返回布尔值                                                 |  |
| **删除键值对**   | `.delete(key)`     | `map.delete('a')` → 成功删除返回 `true`，否则 `false`                        |  |
| **清空Map**      | `.clear()`         | 删除所有键值对：`map.clear()`                                                |  |
| **获取大小**     | `.size`            | 属性直接访问：`map.size` → 返回键值对数量                                    |  |
| **遍历键**       | `.keys()`          | 返回迭代器：`for (let key of map.keys()) { ... }`                           |        |
| **遍历值**       | `.values()`        | 返回迭代器：`for (let val of map.values()) { ... }`                         |        |
| **遍历键值对**   | `.entries()`       | 返回 `[key, value]` 数组迭代器：`for (let [k,v] of map.entries()) { ... }`   |        |
| **迭代全部元素** | `.forEach()`       | `map.forEach((value, key) => { ... })`（注意参数顺序为 `值, 键`）            |        |

#### typeof

检查变量类型，返回字符串，表示数据类型  

```js

console.log(typeof undefined); // "undefined"
console.log(typeof true);      // "boolean"
console.log(typeof 42);        // "number"
console.log(typeof "hello");   // "string"
console.log(typeof {});        // "object"
console.log(typeof []);        // "object"
console.log(typeof null);      // "object" (特殊情况)
console.log(typeof function(){}); // "function"
console.log(typeof Symbol());  // "symbol"
console.log(typeof 10n);       // "bigint"

```

主要用于基本数据类型、函数、未定义类型、symbol

#### instanceof

检测某个对象是否是另一个对象（构造函数）的实例，返回布尔值  
用于检测对象的具体类型  

#### 遍历对象属性

Object.keys  
Object.getOwnPropertyNames  
Object.entries  
for...in  

#### 读取二进制文件

ArrayBuffer

### API

## 面试

### for in 和 for of

| **对比维度**         | **`for...in`**                                                                 | **`for...of`**                                                                 |
|----------------------|-------------------------------------------------------------------------------|-------------------------------------------------------------------------------|
| **遍历对象类型**      | 普通对象、数组等可枚举属性（包括原型链属性）                                   | 可迭代对象（数组、字符串、Map、Set、TypedArray、NodeList 等）                  |
| **遍历内容**          | 对象的键名（Key）或数组的索引（字符串形式）                                   | 可迭代对象的值（Value）                                                       |
| **适用数据结构**      | 对象、数组（不推荐用于数组遍历）                                               | 数组、字符串、Map、Set 等支持迭代器的数据结构                                 |
| **原型链属性处理**    | 会遍历原型链上的可枚举属性，需用 `hasOwnProperty` 过滤                        | 仅遍历对象自身的可迭代值，不涉及原型链                                        |
| **循环控制语句支持**  | 支持 `break`、`continue`                                                      | 支持 `break`、`continue`                                                       |
| **返回值类型**        | 数组索引为字符串（如 `"0"`）                                                  | 数组元素为原始类型或对象（如 `1`、`{name: 'John'}`）                           |
| **顺序保证**          | 不保证顺序（对象属性无序）                                                     | 按可迭代对象内部顺序遍历（如数组按索引顺序）                                   |
| **自定义迭代能力**    | 无                                                                            | 可通过实现 `Symbol.iterator` 方法使普通对象可迭代                             |

### forEach() 和 map() 

forEach()和map()方法通常用于遍历Array元素  

forEach()方法：  
返回 undefined  
不能与其他方法链接   

map()  
返回一个包含已转换元素的新数组  
可以链接  
性能更好  

### 如何判断变量是数组

1. Array.isArray() 判断
2. instanceof 判断
3. Object.prototype.toString.call()
4. Array.prototype.isPrototypeOf
5. 原型链判断


# TS

## 简单知识

### 类型

基础类型
- string
- number
- boolean
- null
- undefined
- symbol
- bigint

复杂类型
- array 数组
- tuple 元组
- enum 枚举
- object  
    表示非原始类型的值，如对象、数组等  

特殊类型  
- any
- unknown
- never
- void

*还有联合类型（|）和交叉类型（&）*  
- 联合类型通过|符号连接多个类型从而生成新的类型。它主要是取多个类型的交集，即多个类型共有的类型才是联合类型最终的类型。  

## d.ts 文件

类型声明文件

## 面试

### TypeScript 中 type 和 interface 的区别

定义类型的两种核心工具

interface  
- 声明对象的形状（面向对象范式）  
- 仅能描述对象/函数类型  
- 以继承机制扩展  
- 性能更好（适合高频类型检查）

type  
- 类型别名（函数式编程思维）  
- 可描述任意类型（联合、元组等）  
- 强调灵活性，适合复杂类型操作  
- 以交叉类型（&）扩展

# vue

**MVVM模式**
- Model-View-ViewModel,核心是提供对View和VIewModel的双向数据绑定
- Vue提供了MVVM风格的双向数据绑定，核心是MVVM中的VM，ViewModel负责连接View和Model，保证视图和数据的一致性

## Vue Router

Vue Router 是 Vue.js 的官方路由管理器，用于构建单页面应用（SPA），通过动态管理 URL 与组件的映射关系实现无刷新页面切换。  

- 路由映射  
  将 URL路径与 Vue 组件绑定，通过 routes 数组配置  
- 路由出口  
  通过 `<router-view>` 渲染匹配组件， `<router-link>` 生成导航链接  
- 路由模式  
  Hash 模式、History 模式、Memory 模式（适用于非浏览器环境，不依赖 URL）  
- 动态路由与参数  
- 导航方式  
- 重定向与别名  
  配置 redirect 属性  
  alias 属性允许多个路径渲染同一组件  
- 404 处理  
  用通配符路径 `path: '/:pathMatch(.*)*'` 匹配未定义路由，渲染错误页面  
- 路由守卫  
- 懒加载  
- 嵌套路由  
- 
### Hash 模式与 History 模式

#### Hash 

Hash模式是Vue Router的默认模式，它使用URL的hash(即#号及其后面的部分)来模拟完整的URL。  

特点：  
- URL 中包含`#`符号  
- 通过`window.location.hash`获取当前 URL 的 hash 值。  
- 通过`window.onhashchange`监听 hash 值的变化。  
- hash 值不会包含在 HTTP 请求中，对服务器完全无用  
- 每次改变 hash 都会在浏览器访问历史中增加一个记录  
- 兼容性好  

#### History

History模式基于HTML5的History API，提供了更"干净"的URL，没有#符号。  

特点：  
- URL 更直观  
- 使用`history.pushState()`和`replaceState()`方法修改 URL  
- 通过`window.onpopstate`监听路由变化  
- 要服务端支持  
- 需要浏览器支持HTML5 History API，不兼容IE9及以下版本  

### Vue Router 中如何获取路由传递的参数

#### 动态路由匹配

使用`/user/:id`这样的路径来定义一个动态参数路由  
然后通过`this.$route.params`来获取传递的参数   

#### 查询参数

在 URL 中使用查询字符串的形式传参，`/user?id=123`  
然后通过`this.$route.query`来获取传递的参数   


## 面试

- template 标签
    占位符

### Vue2 与 Vue3 核心区别对比表

| 特性                 | Vue2                                                                 | Vue3                                                                                               | 引用来源                  |
|----------------------|---------------------------------------------------------------------|---------------------------------------------------------------------------------------------------|-------------------------|
| **API 设计**         | Options API（逻辑分散在 `data`、`methods` 等选项中）                 | Composition API（通过 `setup()` 集中逻辑，支持复用）                                                |  |
| **响应式系统**       | 基于 `Object.defineProperty`（无法检测动态属性/数组索引）           | 基于 `Proxy`（支持动态属性、深层嵌套对象/数组监听）                                                   |  |
| **生命周期钩子**    | 直接定义（如 `mounted()`）                                           | 钩子名前加 `on`（如 `onMounted()`），需显式引入；`setup()` 替代 `beforeCreate` 和 `created`        |  |
| **模板根节点**       | 必须单根节点，需外层 `<div>` 包裹                                   | 支持多根节点（Fragments）                                                                           |  |
| **TypeScript 支持**  | 需额外配置，类型推断较弱                                            | 原生深度支持，类型推导更完善                                                                         |  |
| **性能优化**         | 较慢的虚拟 DOM 和响应式初始化                                       | 虚拟 DOM 优化（`patchFlag` 标记静态节点）、Tree-shaking 减少体积、Proxy 响应式性能更优               |  |
| **新组件特性**       | 无                                                                  | 新增 `Teleport`（渲染到任意 DOM 节点）、`Suspense`（异步组件加载状态管理）                           |  |
| **全局 API**         | `Vue.use()`、`Vue.component()` 等全局方法                          | 模块化引入（如 `createApp()`），避免全局污染                                                         |           |
| **自定义指令**       | 钩子函数如 `inserted`、`update`                                     | 钩子名更新（如 `mounted`、`updated`），支持更灵活的生命周期                                           |               |
| **v-model**          | 单个绑定（`value` + `input` 事件）                                  | 支持多绑定（如 `v-model:title`），可自定义事件名                                                      |         |
| **逻辑复用**         | Mixins（易命名冲突）                                                | 组合式函数（Composables），通过函数封装逻辑                                                          |               |
| **SSR 支持**         | 支持但优化较少                                                      | 流式渲染、静态节点优化，性能提升                                                                     |               |
| **体积与 Tree-shaking** | 较大，无法按需引入                                                | 更小（约 10KB），支持 Tree-shaking 剔除未使用代码                                                    |     |


### Vue 的生命周期

初始化、挂载、更新、销毁  

- beforeCreate:创建前  
  在beforeCreate阶段，还不能访问data、computed、watch、methods上的方法和数据。  
- created：创建后  
  在created阶段，可以访问data、computed、watch、methods上的方法和数据。不能访问$el等属性  
- beforeMount：挂载前  
  已经把data里的数据和模板生成html，但是还没有把html挂载到界面  
- mounted：挂载后  
  可以正常获取DOM元素 beforeUpdate：更新前，获取不到更新的真实DOM  
- update：更新后  
  获取的是更新的真实DOM beforeDestroy：销毁前（比如采用v-if的方式，移除组件）   
- destroyed：销毁后  

### 虚拟 DOM

虚拟DOM（Virtual DOM）是一种用于优化页面渲染性能的技术，其核心原理是通过 JavaScript 对象对真实DOM进行抽象描述，并作为中间层协调视图更新。  

1. 抽象表示
  虚拟DOM通过轻量级的JS对象（如tagName、props、children等属性）模拟真实DOM结构。例如，一个`<div>`节点会被表示为：
  ```Js
  { tag: 'div', props: { id: 'app' }, children: [...] }
  ```
  这种抽象使得操作成本远低于直接操作真实DOM。
2. 更新流程
  初次渲染：将虚拟DOM转化为真实DOM并挂载到页面。
  状态变更：生成新的虚拟DOM树。
  差异对比（Diff算法）：比较新旧虚拟DOM树的差异。
  批量更新：仅将差异部分应用到真实DOM，减少重绘和回流。
3. 核心优势
  性能优化：通过批量更新减少DOM操作次数。
  跨平台能力：虚拟DOM可适配不同平台（如Web、Native），只需实现对应的渲染逻辑。
  开发友好性：开发者无需手动优化DOM操作。

#### Diff 算法实现原理

Diff算法是虚拟DOM的核心，用于高效找出新旧虚拟DOM树的差异。其核心策略包括：  
1. 分层比较  
  仅比较同一层的节点，如果节点跨层移动，直接删除旧节点，创建新节点。  
2. 双端对比（Vue）  
  头头、尾尾、头尾、尾头 匹配，减少遍历次数。  
3. Key 的作用  
  通过唯一 key 标识节点身份，避免复用导致顺序错乱。  
  列表渲染中，可帮助 Diff 快速定位可复用节点。  
4. 动态节点标记（Vue3 优化）
  Vue3在编译阶段通过patchFlag标记动态节点（如绑定响应式变量的元素），运行时直接定位变更部分，跳过全树对比。  
  
### 如何实现双向绑定？原理？

使用 ref 来新建双向绑定对象  

#### 核心原理

1. 劫持数据对象的属性读写操作，建立响应式系统。
  Vue 3.x：改用Proxy代理整个对象，支持深层监听和数组操作，性能更优  
  ```js
  const proxy = new Proxy(obj, {
    get(target, key) { track(target, key); },  // 依赖收集
    set(target, key, value) { 
      trigger(target, key);  // 触发更新
      return Reflect.set(target, key, value);
    }
  });
  ```
2. 发布-订阅模式  
  通过 Dep 和 Watcher 管理依赖关系：  
  - Dep 每个被劫持的属性关联一个 Dep 实例，负责存储所有依赖它的 Watcher  
  - Watcher 在组件渲染或计算属性时创建，订阅数据变化，触发视图更新  

#### 实现流程

1. 初始化
  数据劫持  
  依赖收集  
2. 编译阶段
  指令解析  
  事件监听  
3. 更新阶段
  派发更新  
  虚拟 DOM 优化

### computed 和 watch

computed：  
- 它根据响应式数据的变化自动重新计算值  
- computed属性的计算结果会被缓存，只有当其依赖的响应式数据发生变化时，计算属性才会重新计算。  

watch：  
- watch允许你指定一个或多个响应式数据，并对这些数据的变化执行自定义的操作。  
- watch不会缓存结果，每次指定的数据变化时，都会执行相应的操作。  

### provide/inject 机制

Vue3 的 Provide/Inject 机制是一种跨层级组件通信的解决方案，允许父组件向任意深度的子孙组件直接传递数据，避免了通过 props 逐层传递的繁琐。  


### 为什么 data 属性是一个函数而不是一个对象

可以在每次创建新组件实例时返回全新对象，确保每个组件实例有一个独立的数据作用域  

### v-if 和 v-show 有什么区别？使用场景是什么

v-show  
    通过 CSS display 属性来显示或隐藏元素，无论条件是否为真，都会被渲染到 DOM 中  
    会触发 CSS 过渡效果
    频繁切换显示/隐藏状态的场景  
    
v-if  
    通过条件决定是否渲染元素，如果条件为否，不会被渲染到 DOM 中  
    要配合 vue 的 transition 组件过渡  
    不频繁切换的场景  

### slot

slot 是什么有什么用

是一种用于在组件模板中分发内容的机制。  
用它来将父组件的内容传递给子组件,从而实现灵活的内容分发和复用  

- 默认插槽  
    只有一个插槽  
- 具名插槽
    一个组件多个插槽  
- 作用域插槽
    允许父组件使用子组件提供的数据  
- 条件插槽  
- 动态插槽  

### 渲染模板时，如何保留模板中的 HTML 注释

默认情况下不会保留，但可以使用 v-html 指令实现  

```html

<template>
  <div v-html="htmlContent"></div>
</template>

<script>
export default {
  data() {
    return {
      htmlContent: '<!-- This is an HTML comment -->'
    };
  }
};
</script>

```
### 如何设计弹窗组件

1. 组件结构，模板、脚本、样式
2. 显示与隐藏逻辑
3. 过渡效果  
    vue 提供的 transition 组件可以实现淡入淡出的效果  
4. 插槽（slot），为弹窗内容提供灵活扩展性
5. 事件处理
6. 样式

### v-cloak v-pre 有什么作用

#### v-cloak  

主要用来防止闪烁，在 vue 完全编译前，将绑定的 DOM 元素添加 display：none 样式，避免未解析模板直接显示  

```html
<style>
[v-cloak] { display: none; }
</style>

<div v-cloak>
{{ message }}
</div>
```

#### v-pre  

跳过该节点及其子节点的编译过程，直接输出原始的 Mustache 标签（插值符号{{}}）  
提高性能有一定帮助  

```html
<div v-pre>
  {{ rawMustache }}  <!-- 这里的内容将会直接输出为 {{ rawMustache }} 而不是进行数据绑定 -->
</div>
```

### 过滤器

用于格式化显示文本、日期、货币等  
用 method 实现  

```javascript
export default {
  methods: {
    capitalize(value) {
      if (!value) return '';
      value = value.toString();
      return value.charAt(0).toUpperCase() + value.slice(1);
    }
  }
}
```
```html
<p>{{ capitalize(message) }}</p>
```

### 如何配置 404 页面

使用 * 通配符（匹配所有未定义路径） + NotFound 组件  
**要放在最后**

### 如何实现复杂的表单验证和提交逻辑

- 使用组件（element plus）
- VeeValidate、Yup 工具  
- 非空、正则表达式

### 如何解决页面请求接口大规模并发问题

- 前端并发控制  
    请求合并  
    请求队列  
    防抖节流：对频发请求进行控制  
- 数据缓存  
    前端缓存：利用浏览器缓存、local storage 等机制缓存数据  
    接口缓存：合理设置 HTTP 缓存头、利用 CDN 缓存  
- 服务端优化  
    数据库优化  
    服务端缓存  
    负载均衡  

# Node.js

## 简单知识

### 特性

- 高性能  
- 非阻塞I/O  
- 单进程异步  
- 事件驱动  
- 轻量级与高扩展性  
  跨平台、生态大  

### 全局对象

在任何地方都能直接访问的对象。这些对象提供了一些基本的功能和常用的工具函数.  

#### global

Node.js 的全局命名空间对象，类似浏览器中的 window 对象。  

#### process

全局对象，提供了有关当前 Node.js 进程的信息和控制，让我们可以与操作系统进行交互。  

常用属性  
- process.argv
- process.env
- process.exit()
- process.cwd()
- process.memoryUsage()
- process.uptime()
- process.nextTick(callback)

#### __dirname and __filename

__dirname:  
    当前脚本文件所在目录的绝对路径

__filename:  
当前脚本的绝对路径

#### console

用于打印标准输出和错误输出信息  

#### module exports

系统模块相关，用于导出和导入模块

#### 定时器函数

setTimeout(), clearTimeout(), setInterval(), clearInterval()  

#### Buffer

Buffer 对象是 Node.js 中的一个全局类，用来在处理二进制数据时，提供对内存缓冲区的操作能力。  
作用：  
- 处理二进制数据
- 与流结合  
    文件处理、网络传输  
- 转换编码格式  

### 包管理器

#### npm

Node Package Manager

用于安装、共享、管理和控制 JavaScript 包及其依赖版本  
- 初始化项目
- 安装依赖  
- 保存依赖
- 更新依赖
- 删除依赖

- 全局安装和局部安装
- npm scripts
- 版本范围控制
- npx
- 私有 npm 仓库
- 依赖安全性检查
- 锁文件

### 特殊文件

package.json  
- 描述项目信息
- 定义项目依赖
- 管理脚本命令
- 项目其他配置信息

### Promise 的特点

- 状态不可逆性
  三种明确状态-Promise 的状态只能是以下三者之一：  
    Pending（进行中）：初始状态，尚未完成或拒绝。  
    Fulfilled（已兑现）：异步操作成功完成，通过 resolve() 触发。  
    Rejected（已拒绝）：异步操作失败，通过 reject() 或抛出异常触发。 状态一旦从 Pending 变为 Fulfilled 或 Rejected，便不可逆且不可修改。  
  状态由内部结果决定  
    Promise 的状态仅由异步操作的结果决定，外部无法直接干预，保证了操作的原子性   
- 链式调用  
- 无法取消  
- 微任务队列  
  执行时机早于宏任务  
- 静态方法支持复杂场景  
  Promise.all()：并行执行多个 Promise，全部成功时返回结果数组，任一失败则整体失败。  
  Promise.race()：返回首个完成的 Promise 结果。  
  Promise.resolve()/reject()：快速创建已确定状态的 Promise  

### 同步和异步

同步：  
顺序执行  

异步：
不会阻塞后续代码的执行。异步操作会在完成时通过回调函数、Promise 以及 async/await 等机制通知相关的代码去处理结果。  

### 事件循环

node.js 处理异步操作的基础  

| 阶段名称               | 执行任务                                                                 | 示例 API/场景                          |
|------------------------|--------------------------------------------------------------------------|----------------------------------------|
| **Timers**             | 执行 `setTimeout` 和 `setInterval` 的回调。                              | `setTimeout(fn, 0)`                   |
| **Pending I/O**        | 处理系统操作（如 TCP 错误、文件读写）的完成回调。                         | `fs.readFile` 的完成回调               |
| **Idle/Prepare**       | Node.js 内部使用（轮询准备阶段，开发者通常无需关注）。                    | -                                      |
| **Poll**               | 1. 检索新的 I/O 事件并执行回调。<br>2. 计算阻塞时间（等待下一个事件循环）。 | `net.Server` 的连接事件                |
| **Check**              | 执行 `setImmediate` 的回调（在 Poll 阶段完成后立即执行）。                | `setImmediate(fn)`                     |
| **Close Callbacks**    | 执行关闭事件的回调（如 `socket.on('close', ...)`）。                     | `socket.destroy()` 触发的关闭回调       |

依赖一个名为 Libuv 的库（事件驱动的跨平台非阻塞 I/O 库。  

### require 和 import

引入模块的两种不同方式  
require  
- 基于 CommonJS  
- 同步加载模块并立即执行  
- 原生支持  

import  
- 基于 ES6  
- 异步加载  
- 需要 babel 等编译器支持  

最近的 Node.js 版本中（14.0.0及以上），原生支持 ESM

### node.js 模块的加载机制

主要依赖 CommonJS 规范。实现了模块的导入和导出，让开发者可以将代码分成独立的文件和模块进行组织、复用。
加载过程包括路径解析、文件类型识别、编译和缓存等步骤。  

### 回调、Promise、async/await

处理异步操作的三种不同方式

| 特性                  | 回调（Callback）                                                                 | Promise                                                                 | async/await                                                                 |
|-----------------------|---------------------------------------------------------------------------------|-------------------------------------------------------------------------|-----------------------------------------------------------------------------|
| **语法结构**          | 嵌套回调（易产生“回调地狱”）                                                    | 链式调用（`.then()`、`.catch()`）                                       | 同步代码风格（`async`、`await` 关键字）                                      |
| **错误处理**          | 手动传递错误（如 `if (err) {}`）                                                 | 通过 `.catch()` 统一捕获                                                 | 通过 `try/catch` 捕获                                                        |
| **可读性**            | 嵌套层级深时难以维护                                                            | 链式结构更清晰                                                          | 代码结构最接近同步逻辑，易读性强                                             |
| **链式调用**          | 需手动嵌套回调                                                                  | 支持链式调用（可返回新 Promise）                                         | 隐式链式调用（通过顺序执行 `await`）                                          |
| **兼容性**            | 所有 JavaScript 环境                                                            | ES6+（需 Polyfill 兼容旧浏览器）                                         | ES2017+（需 Babel 转译）                                                     |
| **适用场景**          | 简单异步操作、传统 Node.js 库（如 `fs.readFile`）                               | 复杂异步流程（如多级依赖请求）                                           | 需要同步代码风格的异步操作（如逻辑复杂的异步控制）                           |
| **错误冒泡**          | 需逐层传递错误                                                                  | 支持冒泡到最近的 `.catch()`                                              | 支持冒泡到外层 `try/catch`                                                   |
| **返回值**            | 无（通过回调函数返回结果）                                                      | 返回 Promise 对象                                                        | 返回 Promise 对象（`async` 函数）                                            |
| **并行处理**          | 需手动实现（如计数器或第三方库）                                                 | 通过 `Promise.all()`、`Promise.race()` 处理                              | 结合 `Promise.all()` 使用（如 `await Promise.all([p1, p2])`）                |
| **调试体验**          | 堆栈信息不连贯                                                                  | 堆栈信息较清晰                                                          | 堆栈信息清晰（模拟同步调试）                                                 |

回调函数就是用参数传递给另一个函数的函数  

## JSON 数据

- JSON.prase  
    JSON 数据转为 JS 对象  
- JSON.stringify  
    JS 对象转为 JSON 数据  
- 通常异步读取
- 验证 JSON 数据  
    ajv库

## 如何在 Node.js 中高效处理日志，避免影响性能  

- 异步记录  
- 日志级别控制  
- 日志轮转  
    限制单个日志文件大小  
- 批量写入  
- 缓冲机制

# 设计模式

设计模式是一套在软件工程中经过验证的、用于解决特定设计问题的解决方案模板，它们帮助开发者避免重复发明轮子，确保设计的一致性和可维护性，提高代码的可读性和可扩展性。  

## 单例模式

需要确保某个类只有一个实例，并提供一个全局访问点的时候  
如配置管理器、全局缓存  

## 简单工厂模式

利用一个工厂作为入口，将多个对象的创建和使用分离，  
根据传入的参数来创建并返回不同的对象实例。  

传入不同的支付渠道，实现不同的支付方法  

## 策略模式  

行为型设计模式，它定义了一系列算法，把每个算法封装起来，让他们可以相互替换。  
主要目的是为了解耦多个策略  

特点：  
- 算法封装  
- 动态替换  
- 遵循开闭原则

组成：  
- 策略接口  
- 具体策略  
- 上下文类  

支付场景需要不同的支付渠道，对应不同的策略，适合策略模式  
分数有不同的算法 平均值、最大值。

## 模板方法模式

行为型设计模式，在抽象类中定义了一个算法（业务逻辑）的骨架，具体步骤放在子类中，达到代码复用和扩展的目的  
- 算法骨架  
- 复用代码  
- 遵循开闭原则  

组成：  
- 抽象类
- 具体类  
- 模板方法  

场景：  
- 数据处理
- Web 请求  
- 组件  

## 代理模式

一种结构型设计模式，在不改变原始对象的前提下  
通过引入一个代理对象来控制对原始对象的访问，实现额外的功能。  
如控制权限、延迟加载、缓存等  


特点：  
- 间接访问  
- 功能增强  
- 解耦性  

- 远程代理  
- 权限代理  
- 智能引用  

- 访问控制
  对实际对象的访问需要进行权限验证时。
- 性能优化
- 远程访问
- 日志记录

## 原型模式

创建型设计模式  
主要通过复制现有的实例来创建新的对象  
避免复杂创建过程，提升创建对象的效率。  

- 克隆对象  
- 深拷贝与浅拷贝  
- 动态扩展性  

- 创建对象成本高  
- 需要多个相似对象  

- 文档编辑器中模板文档的创建  
- 游戏开发中怪物或物品的批量生成  



# 前端

## 功能实现

### 小功能

#### 日期格式化

### 业务功能

#### 前端如何实现扫码登录功能

1. 前端向服务器发起请求生成一个唯一的二维码  
2. 展示二维码并轮询检查扫码状态  
3. 手机端扫码成功后通知服务器,服务器再通知前端  
4. 前端收到扫码成功的消息后，执行登录逻辑  

- websocket 实时推送扫码状态更好，减少轮询频率，提高响应速度  
- 二维码要有时效性，可使用 JWT 令牌或 Redis 缓存  
- 兼容性  

#### 如何实现单点登录

单点登录（Single Sign-On，SSO）是一种认证机制，允许用户在多个独立的系统或应用之间，只需一次登录就能访问所有的系统或应用。  
实现通常依赖于后端的支持和浏览器的 Cookie 机制  

#### 如何解决 SPA 应用首屏加载速度慢的问题

- 按需加载、代码分割
- 服务端渲染（SSR）
- 使用骨架屏
- CDN 加速

#### 如何设计一款能够统计前端页面请求耗时的工具

1. 使用 XMLHttpRequest 或 fetch API 拦截请求和响应  
2. 记录发起请求的事件和收到响应的时间
3. 计算时间差
4. 存储数据
5. 数据展示

#### 如何设计和优化秒杀系统的前端

- 界面设计
- 性能优化
- 防止刷量和攻击
- 用户体验

#### 无限滚动加载和自动回收上面的内容

- 使用 Intersection Observer API 监听元素进入/离开视口，从而触发操作。
- 动态创建和删除 DOM 元素  

#### 文件的断点续传，并确保大文件安全可靠上传

- 文件分块上传  
- 断点续传标识
- MD5 校验
- 并发上传
- 进度监控

#### WebSocket 的实时聊天功能，支持多用户在线聊天并展示消息通知

1. 建立 WebSocket 连接  
    前端需要和服务器建立 WebSocket 连接  
2. 处理连接事件
3. 发送消息
4. 接收消息
5. 显示消息通知

#### 如何设计前端日志埋点 SDK

- 数据捕获  
    按钮点击、页面加载时间  
- 数据过滤  
- 数据传输  
- 数据存储  
- 灵活配置  
- 性能优化  

#### 添加水印

- html、css、js 实现
- canvas、多重水印

#### 实时补全搜索框

1. 输入框捕捉输入
2. 事件监听器捕捉输入内容
3. 每当输入时，触发 AJAX 请求（Fetch API 或 Axios）发送到服务器，获取匹配词推荐  
4. 服务器返回  
5. 前端显示

#### 如何对每个 JavaScript 函数的执行实现拦截  

使用 JS 的 Proxy 和 Reflect 这两个对象。  
Proxy 对象用于定义自定义行为（函数调用、属性访问等）的拦截器  
Reflect 可以确保原生操作的默认行为得以执行  

## 面试

### 隐藏元素的方法

- display:none  
    彻底移除
- visibility:hiden  
    仍然占据空间  
    占位隐藏  
- opacity:0  
    占空间、可交互  
    透明动画或交互隐藏  
- position:absolute + 偏移
- clip-path 或 clip:rect(0，0，0，0)  
    裁剪  
- width:0;height:0 overflow: hidden  
- HTML 的 hidden  
- z-index < 0 + position  
- JS 控制
- jQuery 方法

### Tree Sharking

Tree Shaking（摇树优化）是一种用于优化 JavaScript 应用的静态代码分析技术，其核心目标是通过移除未使用的代码（即“死代码”）来减小最终打包文件的体积，从而提升应用加载速度和运行性能。这一概念最早由 Rollup 提出，现已成为现代前端构建工具（如 Webpack、Rollup、Vite 等）的标配功能。  

核心原理：  
- 基于 ES6 模块的静态分析  
  Tree Shaking 依赖于 ES6 模块（ESM）的静态结构特性（import/export），因为 ESM 的依赖关系在编译时即可确定，而非像 CommonJS 模块那样动态解析。这使得构建工具能够通过抽象语法树（AST）分析代码的导出与引用关系，精确识别未使用的模块或变量。  
  若模块导出了 A 和 B，但仅 A 被其他模块引用，则 B 会被移除。  
- 死代码消除（DCE）的进阶形式  
  传统 DCE 仅移除不可能执行的代码（如未调用的函数），而 Tree Shaking 更关注未引用的模块或导出值。  
- 与副作用（Side Effects）的关联  
  若模块包含副作用（如修改全局变量、立即执行函数等），Tree Shaking 会保留这些代码以避免破坏程序逻辑。开发者可通过 package.json 的 "sideEffects" 字段显式标记这类模块（如 CSS 文件）。
  
### Rollup

Rollup 是一款专注于 JavaScript 模块打包 的工具，由 Rich Harris（Svelte 作者）开发。它的设计理念与 Webpack 有显著不同，更强调 轻量、高效和面向未来的模块化代码。  

核心设计理念：  
- 面向 ESM  
- Tree Shaking 优先  
- 简单高效  
- 适合库/框架开发  

核心特性：  
- Tree Shaking  
- 输出格式灵活  
- 插件系统  
- 代码分割  

### Vite 和 Webpack

Vite：  
- 开发环境无需打包，速度快
- 生产环境使用 Rollup 打包，支持 Tree Shaking、代码分割等优化  
- 热更新效率高  

Webpack：  
- 全程打包  
- 成熟的生态系统，支持复杂的代码分割、插件扩展和旧浏览器兼容。  
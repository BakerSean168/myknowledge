# 前端工程化

### 隐藏元素的方法

- display:none  
    彻底移除
- visibility:hiden  
    仍然占据空间  
    占位隐藏  
- opacity:0  
    占空间、可交互  
    透明动画或交互隐藏  
- position:absolute + 偏移
- clip-path 或 clip:rect(0，0，0，0)  
    裁剪  
- width:0;height:0 overflow: hidden  
- HTML 的 hidden  
- z-index < 0 + position  
- JS 控制
- jQuery 方法

### Tree Sharking

Tree Shaking（摇树优化）是一种用于优化 JavaScript 应用的静态代码分析技术，其核心目标是通过移除未使用的代码（即“死代码”）来减小最终打包文件的体积，从而提升应用加载速度和运行性能。这一概念最早由 Rollup 提出，现已成为现代前端构建工具（如 Webpack、Rollup、Vite 等）的标配功能。  

核心原理：  
- 基于 ES6 模块的静态分析  
  Tree Shaking 依赖于 ES6 模块（ESM）的静态结构特性（import/export），因为 ESM 的依赖关系在编译时即可确定，而非像 CommonJS 模块那样动态解析。这使得构建工具能够通过抽象语法树（AST）分析代码的导出与引用关系，精确识别未使用的模块或变量。  
  若模块导出了 A 和 B，但仅 A 被其他模块引用，则 B 会被移除。  
- 死代码消除（DCE）的进阶形式  
  传统 DCE 仅移除不可能执行的代码（如未调用的函数），而 Tree Shaking 更关注未引用的模块或导出值。  
- 与副作用（Side Effects）的关联  
  若模块包含副作用（如修改全局变量、立即执行函数等），Tree Shaking 会保留这些代码以避免破坏程序逻辑。开发者可通过 package.json 的 "sideEffects" 字段显式标记这类模块（如 CSS 文件）。
  
### Rollup

Rollup 是一款专注于 JavaScript 模块打包 的工具，由 Rich Harris（Svelte 作者）开发。它的设计理念与 Webpack 有显著不同，更强调 轻量、高效和面向未来的模块化代码。  

核心设计理念：  
- 面向 ESM  
- Tree Shaking 优先  
- 简单高效  
- 适合库/框架开发  

核心特性：  
- Tree Shaking  
- 输出格式灵活  
- 插件系统  
- 代码分割  

### ref 和 reactive



以下是纯 Markdown 表格的原始文本，可直接复制使用：

| 特性     | `ref`                           | `reactive`         |
| -------- | ------------------------------- | ------------------ |
| 数据类型 | 所有类型                        | 仅对象类型         |
| 访问方式 | 需 `.value`（模板自动解包）     | 直接访问属性       |
| 实现原理 | `RefImpl` + 内部调用 `reactive` | Proxy 代理         |
| 对象替换 | 支持                            | 不支持             |
| 深层监听 | 需显式启用 `deep: true`         | 默认支持           |
| 适用场景 | 基本类型、灵活替换对象          | 复杂对象、嵌套结构 |

### Vite 和 Webpack

Vite：  
- 开发环境无需打包，速度快
- 生产环境使用 Rollup 打包，支持 Tree Shaking、代码分割等优化  
- 热更新效率高  

Webpack：  
- 全程打包  
- 成熟的生态系统，支持复杂的代码分割、插件扩展和旧浏览器兼容。  

### key 字段的作用

核心作用：  
- 虚拟 DOM 的节点识别  
  key 是框架用于区分同级元素的唯一标识符。  
  在列表更新时，框架通过对比新旧虚拟 DOM 的 key 快速定位新增/删除/移动的元素（类似数据库主键机制）。
- 组件状态维护  
  确保状态与数据正确绑定  
- 性能优化机制
  框架通过 key 快速识别可复用的元素节点，避免整体重新渲染  

### 进程、线程、协程

#### 进程  

定义：  
- 操作系统进行资源分配和调度的基本单位，是程序运行的实例，拥有独立的内存空间和系统资源。  

#### 线程

定义：  
- 进程内的执行单元，是 CPU 调度的基本单位。  
- 一个进程可以包含多个线程，共享进程的资源  
- 每个线程有自己的栈和寄存器  

特点：  
- 轻量  
- 共享资源  
- 不安全  
  一个线程崩溃可能导致整个进程崩溃  

##### 线程间的通信方式

等待-通知机制  
消息队列  
join 机制  

##### 进程间的通信方式

高级通信机制可归结为四大类： 共享存储器系统、管道通信系统、消息传递系统、客户机-服务器系统  

#### 协程  

定义：  
- 用户态的轻量级进程  
- 程序自身调度  

特点：  
- 极低开销  
- 非抢占式调度  
- 无并行能力  

### docker 与 虚拟机 的区别

#### docker

基于容器技术，共享宿主机的操作系统内核  
通过命名空间（Namespace）和控制组（Cgroup）实现资源隔离  
容器本质上是宿主机的进程  
资源利用率高（硬件利用率可达60%-80%）  
启动速度秒级  
镜像体积小（通常为MB级）  
进程级隔离，安全性较弱  

典型应用场景：  
- 开发环境一致  
- 微服务架构  
- 跨平台应用分发  
- 临时测试环境  

#### 虚拟机

Hypervisor 虚拟化硬件  
运行完整操作系统  
资源消耗大  
启动分钟级  
镜像体积大  
操作系统级隔离  

### SSR 应用

优点：  
- SEO 友好  
  搜索引擎爬虫可以直接抓取服务端生成的完整HTML内容，无需依赖客户端JavaScript执行，显著提升搜索引擎收录效果
- 首屏加载速度快  
  服务器直接返回渲染后的 HTML  
- 低端设备兼容性  
- 内容一致性  

问题：  
- 服务器性能压力  
- 开发复杂度  
- 安全风险  
- 流失渲染与性能优化  
- 部署与运维成本  

### js 有哪些 worker（Web Worker）

Web Worker是HTML5标准的一部分，允许在主线程外创建独立的后台线程（Worker线程）。这些线程与主线程并行运行，不共享内存和DOM，但可通过消息传递机制（postMessage和onmessage）进行通信。  

JavaScript提供了多种 Worker 机制来实现多线程编程  
- Web Workers / Dedicated Workers(专用Worker)：  
  最基本的Worker类型，由主线程创建并专属于创建它的脚本  
  无法访问DOM，通过postMessage与主线程通信  
  适用于CPU密集型计算任务  
- Shared Workers(共享Worker)：  
  可以被多个浏览上下文(不同窗口、iframe等)共享  
  适用于需要跨窗口/标签页共享数据和状态的场景  
- Service Workers：  
  主要用作网络代理，可拦截和处理网络请求  
- Worklets：  
  轻量级专用Worker，用于扩展渲染管道  
- Node.js中的Worker Threads：  
  允许在Node.js中使用真正的多线程  

worker 通信：  
- 通信机制  
  结构化克隆  
  共享内存  
- 使用限制  
  无法操作 DOM  
  同源策略  
  生命周期管理  

### Electron 底层有几个线程  

- 主进程  
- 渲染进程  
- GPU 进程  
- 插件进程  
- 实用程序进程  

#### Cookie

设置存储时间：  
- expires  
  绝对时间  
- max-age  
  相对时间  

存储位置：  
未设置过期时间：会话 Cookie（内存中，关闭浏览器失效）。  
设置过期时间：持久化 Cookie（硬盘中）。  

#### localStorage

使用 localStorage.clear() 方法可以一次性清空当前域名下的所有 localStorage 数据  
通过 localStorage.removeItem(key) 删除特定键值对  
使用函数模拟定期清除  

场景：  
- 用户数据持久化、偏好设置  
- 本地缓存、性能优化  
- 离线应用程序支持  
- 跨页面数据传递  
- 用户登录状态与身份验证  
- 表单数据自动填充  
- 跨标签页通信（监听 storage 事件）  

### PWA

渐进式增强(Progressive Enhancement)  
关键技术组件：  
- Service Worker  
  这是PWA的核心技术之一，负责离线缓存、推送通知、后台同步等功能。Service Worker是一段独立的JavaScript脚本，可以在后台处理网络请求，缓存数据和推送通知   
- Web App Manifest  
  一个JSON文件，用于描述PWA应用的名称、图标、启动URL等信息，让浏览器可以将Web应用添加到主屏幕   
- HTTPS  
  PWA必须通过HTTPS协议提供服务，确保用户数据的安全  
- Push API  
  用于向用户发送推送通知  
- Cache API  
  用于缓存静态资源  

工作原理：  
- 拦截网络请求  
  Service Worker可以拦截应用发出的所有HTTP请求  
- 缓存策略  
  开发者可以自定义缓存策略，决定哪些资源应该被缓存以及如何响应缓存和网络请求  
- 离线支持  
- 后台同步  

### 响应式设计的实现方式

响应式设计（Responsive Web Design, RWD）的核心是通过动态调整布局、内容和功能，使网页适配不同设备的屏幕尺寸和分辨率。  

关键技术：  
- 流式布局  
  使用百分比、vw/vh等相对单位替代固定像素，使元素尺寸随容器或视口变化。  
- 媒体查询  
  通过CSS检测设备特性（如屏幕宽度、方向），应用不同的样式规则。  
- 弹性媒体  
  图片和视频使用max-width: 100%或srcset属性，按需加载适配尺寸的资源。  

### 计算机网络

#### TCP 和 UDP 的区别

TCP 提供面向连接的（三次握手）、可靠的（序列号、确认应答、超时重传）数据传输。  
UDP 提供无连接的、尽最大努力的数据传输服务  
- 传输速率
    TCP 要建立连接和维护可靠性机制，传输速率相对较低  
- 流量控制  
    TCP 有流量控制和拥塞控制机制，能根据网络状态调整传输速率  
    UDP 没有流量控制，以固定速率发送数据   
- 通信模式  
    TCP 支持点对点通信  
    UDP 支持一对一、一对多、多对多、多对一  
- 首部开销  
    TCP 首部较大，至少 20 字节  
    UDP 首部 8 字节  
- 应用场景  
    TCP （高可靠传输）：HTTP、FTP、SMTP  
    UDP （高实时性）：视频会议、游戏、DNS 查询  

#### TCP 流量控制机制

TCP流量控制是一种端到端的协调机制，主要目的是防止发送方发送数据过快，导致接收方来不及接收处理，从而造成数据丢失。其核心是解决发送方与接收方速度不匹配的问题，确保接收方的缓冲区不会溢出。  

滑动窗口机制：  
- 接收窗口(rwnd)  
  接收方通过TCP头部中的Window字段告知发送方自己当前可用的缓冲区空间大小（单位字节）   
- 发送窗口  
  发送方实际可发送的数据量取接收窗口和自身拥塞窗口(cwnd)的较小值   
- 动态调整  
  当接收方应用程序读取数据后，接收窗口会增大并通过ACK通知发送方；当接收方处理不及时导致缓冲区填满时，会减小窗口值甚至设为0  

##### 关键问题

零窗口死锁问题
- TCP 使用持续计时器，发送方定期发送 1 字节 的窗口探测报文查询最新窗口大小  

糊涂窗口综合征
- 问题描述：  
  当接收方频繁通告小窗口时，会导致大量小包传输，降低效率  
- 解决方案：  
  Nagle算法（发送方累积小数据）或接收方延迟通告小窗口  

#### TCP 拥塞控制机制  

拥塞控制是全局性的网络保护机制，目的是防止过多的数据注入网络导致路由器或链路过载。与流量控制不同，它关注的是网络整体承载能力而非单个连接的接收能力。  
TCP通过**拥塞窗口(cwnd)**动态调整发送速率，采用"AIMD"（加法增大/乘法减小）原则。  

核心算法：  
慢启动  
拥塞避免  
快重传  
快恢复  

### 浏览器

#### Session、Cookie、Token 的区别

Cookie：  
存储在客户端的小型文本文件（通常<=4KB）  
服务器通过 Set-Cookie 响应头设置，浏览器后续请求自动携带  
可能被 XSS 或 CSRF 攻击窃取，可通过HttpOnly、Secure等属性提升安全性  
不可跨域(除非设置domain)  
保持用户登录状态、记住用户偏好设置等  

Session：  
存储在服务端，客户端仅保存 Session ID  
服务器创建会话并生成唯一Session ID返回给客户端，客户端后续请求携带此ID  
相对安全(数据在服务端)，但需防范Session ID泄露  
分布式环境下需要特殊处理(如Session共享)  
需要跟踪用户状态的场景，如购物车、表单提交等  

Token：  
存储在客户端(如LocalStorage、Cookie或移动端本地存储)，服务端不保存Token本身  
服务器验证用户身份后生成Token返回，客户端后续请求在Header中携带此Token  
通常使用加密技术生成，较安全，但一旦签发难以主动失效  
API访问控制、单点登录(SSO)等  

### SSL/TLS协议

SSL,Secure Sockets Layer  
  主要用于解决 HTTP 明文传输的安全风险  
TLS,Transport Layer Security  
  SSL3.0 改进并标准化为 TLS1.0,逐渐取代 SSL    

SSL/TLS协议分为两层：  
- 记录协议层  
  作用：对上层数据分块、压缩、加密，并附加MAC值保证完整性  
  加密方式：采用对称加密（如AES）结合CBC模式，初始化向量（IV）由主密钥生成。  
- 握手协议层  

TLS握手流程  
1. ClientHello  
  客户端发送支持的TLS版本、随机数（Client Random）、密码套件列表（如TLS_AES_256_GCM_SHA384）和压缩方法  
2. ServerHello  
3. 密钥交换与验证  
4. 完成握手  

### HTTP

#### 版本改动

| **版本**     | **协议层**       | **关键特性**                                                                                                                              | **改进点**                                                                                   | **局限性**                                                 |
| ------------ | ---------------- | ----------------------------------------------------------------------------------------------------------------------------------------- | -------------------------------------------------------------------------------------------- | ---------------------------------------------------------- |
| **HTTP/1.0** | 基于 TCP         | - 短连接（每次请求需新建 TCP 连接）<br>- 支持缓存（Expires/Last-Modified）<br>- 无 Host 头字段                                            | 首次标准化 HTTP 协议，支持多种数据类型（如 HTML、图片）                                      | - 高延迟（频繁连接/断开）<br>- 队头阻塞（请求按顺序处理）  |
| **HTTP/1.1** | 基于 TCP         | - 默认长连接（Keep-Alive）<br>- 管道化传输（理论支持，默认关闭）<br>- 断点续传（Range 头）<br>- Host 头支持虚拟主机                       | - 减少 TCP 握手开销<br>- 支持部分资源请求                                                    | - 响应队头阻塞（服务器按顺序返回）<br>- 明文传输，安全性低 |
| **HTTP/2.0** | 基于 TCP + TLS   | - **二进制分帧**（Header/Data Frame）<br>- **多路复用**（单连接并发请求）<br>- **头部压缩（HPACK）**<br>- 服务端推送（Server Push）       | - 提升传输效率与带宽利用率<br>- 解决应用层队头阻塞                                           | - 仍依赖 TCP，存在传输层队头阻塞（丢包重传阻塞所有流）     |
| **HTTP/3.0** | 基于 QUIC（UDP） | - **基于 UDP 的 QUIC 协议**<br>- 多路复用（独立流，无队头阻塞）<br>- 头部压缩（QPACK）<br>- 0-RTT 快速握手<br>- 连接迁移（Connection ID） | - 彻底解决 TCP 队头阻塞<br>- 优化移动网络切换（如 IP 变化不影响连接）<br>- 集成 TLS 1.3 加密 | - 新协议兼容性需逐步完善<br>- UDP 可能被部分网络设备限制   |

#### HTTP3 选择了 UDP 的原因

- 解决了 TCP 的局限性  
  - 队头阻塞  
    TCP 要求数据包按序到达  
    UDP 无顺序约束，QUIC 协议通过独立的流实现多路复用，单个流丢包不影响其他流。  
  - 连接建立延迟  
    TCP 三次握手+TLS握手  
    QUIC 基于 UDP 实现 0-RTT 或 1-RTT 握手，显著降低延迟  
  - 协议僵化  
    TCP 协议栈内置操作系统内核，升级困难  
    QUIC 在用户空间实现  
- UDP 的灵活性以及 QUIC 的增强  
  - 可靠性增强  
    QUIC 通过 包编号、ACK 帧、快速重传，避免了 TCP 的重传模糊。  
  - 连接迁移  
    TCP 连接依赖四元组（IP+端口），网络切换要重连  
    QUIC 用 64 位连接 ID，IP 变化时仍可保持连接  
  - 内置加密  
    QUIC 默认集成 TLS 1.3  
- 适应现代网络需求  
  - 移动互联网以及弱网环境  
  - 多路复用与流优先级  
  - 绕过中间设备限制  
    新型传输协议常被防火墙拦截，UDP 广泛兼容，成本低  

### 前端工程化

前端工程化是指将软件工程的技术和方法应用于前端开发，通过规范化、标准化和自动化的手段，提高开发效率、保障代码质量并降低维护成本。  
核心目标是解决四大问题：  
- 开发效率  
- 协作规范  
- 性能优化  
- 质量保障  

四大核心支柱：  
- 模块化  
    JS 模块化  
      CommonJS、AMD、CMD、ESM 等规范，解决全局变量污染、依赖管理问题  
    CSS 模块化  
      Sass/Less/Stylus 等预处理器，以及 CSS Module、CSS-in-JS  
    资源模块化  
      Webpack等工具将图片、字体也视为模块  
- 组件化  
- 规范化  
  代码规范  
  目录结构  
  工作流程  
  文档规范  
- 自动化  
  构建工具
  开发辅助

## 面试（）

### 多次

#### js 类型判断

1. typeof
2. instanceof
3. constructor 属性  
4. Object.prototype.toString.call()  
5. 特定类型判断方法  
  Array.isArray()  
  isNaN()  

##### 如何判断变量是数组

1. Array.isArray() 判断
2. instanceof 判断
3. Object.prototype.toString.call()
4. Array.prototype.isPrototypeOf
5. 原型链判断


#### :key 的作用

:key 是 Vue 中的一个特殊属性，主要用于唯一标识虚拟DOM节点，帮助Vue更高效地更新和渲染DOM。它的主要作用包括：  
- 唯一标识元素身份  
  在列表渲染(v-for)或动态组件切换时，通过key可以精确识别每个节点 
- 优化渲染性能  
  通过key的比较，Vue可以复用已有DOM节点，减少不必要的DOM操作，将算法复杂度从O(n³)优化到O(n)  
- 保持组件状态  
  防止在列表更新时组件状态(如表单输入值)被意外重置或错乱 
- 正确触发过渡动画  
  在元素切换时，不同的key能确保Vue重新创建元素而非复用，从而触发过渡效果  

不使用 key 的后果：  
- 性能下降（无法高效复用）  
- 状态错乱  
- 渲染异常  

使用 index 作为key 的问题：  
当新插入的项目不在最后（eg：在开头插入，新插入的项目的 index 为 0， 则会导致后续的 index 都发生变化），无法达到提升渲染性能的目的。  

底层原理：  
Vue 的虚拟 DOM diff 算法  

#### 浏览器存储方式



### lingyi

#### 编写的 ts 是怎么转换成 js 的  

tsc  

#### 原型链

https://segmentfault.com/a/1190000042725370

原型（prototype）  
- 对象有__proto__属性，函数有__proto__属性，数组也有__proto__属性，只要是引用类型，就有__proto__属性，指向其原型。  
- 只有函数有prototype属性，指向new操作符加调用该函数创建的对象实例的原型对象。

原型链的形成  
- 当访问对象的属性时，若对象自身没有该属性，会通过 [[Prototype]] 逐级向上查找，直到找到或到达链的顶端 Object.prototype（其 [[Prototype]] 为 null）  
- person1.toString() 的查找路径为：person1 → Person.prototype → Object.prototype → null  


### xx

#### 跨域

跨域（Cross-Origin）指浏览器限制从某个域名（源）加载的脚本与另一个域名的资源进行交互的行为。  
核心限制来源于浏览器的同源策略（Same-Origin Policy），该策略要求以下三者必须完全一致才视为“同源”：
- 协议（如 http vs https）  
- 域名（如 a.com vs b.com）  
- 端口（如 80 vs 8080）  
若三者任一不同，则触发跨域限制，表现为无法读取其他源的 Cookie、LocalStorage，或通过 AJAX 发送请求等  

##### 解决方法

- JSONP（JSON with Padding）
  利用 `<script>` 标签的 src 属性无跨域限制的特性，通过动态创建标签发送 GET 请求，服务器返回数据包裹在回调函数中执行。
- CORS(跨域资源共享)  
  通过服务器设置 HTTP 响应头，明确声明允许跨域访问的源、方法和头部信息。  
- 反向代理（Nginx/HTTP Proxy）  
  通过服务器代理转发请求，如配置 Nginx 将 /api 路径代理到目标服务器，绕过浏览器限制。  
- WebSocket  
  基于 WebSocket 协议的双向通信，不受同源策略限制。  
- postMessage  
  允许不同源的窗口间通过 window.postMessage 安全通信，常用于 iframe 跨域。  

### tx

- vue中的 全局状态管理 和 props之类的父子间通信 的区别  
  数据被多个无关组件频繁使用时 全局  
- 正向代理与反向代理  
  正向代理是客户端的代理（个人翻墙、企业内网、内容过滤）；反向代理是服务器的代理（负载均衡、隐藏服务器、缓存加速）  
- pinia 和 vuex 的区别  
- pinia 的存储  
- cookie 和 localstorage 的区别  
- 前端工程化（webpack 打包、减小体积。。。）  
- 一句话讲一下 ts 的泛型  
  是一种创建可复用组件的工具，它允许我们在定义函数、接口或类时不预先指定具体类型，而是在使用时再指定，从而增强代码的灵活性和类型安全性。  
  